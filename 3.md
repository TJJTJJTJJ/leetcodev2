# leetcode

## 3.longest-substring-without-repeating-characters

无重复最长子字符串

如何判断新的字符是否已经在原有的无重复子字符串中是否出现，利用hash表记录位置。

若没有出现，则距离一定大于子字符串的长度。若出现，则距离一定小于等于字符串的长度。

## 5.longest-palindromic-substring

回文字符串，新加入的字符i+1是否构成回文，取决于前一个字符i的所有回文序列。

第三、五题都基于一个假设，当当前的字符串已经处理好想要的结果，如何令再加入一个字符依旧依靠之前的结果得到想要的结果。

**拉马车算法**: 时间复杂度为O(n),空间复杂度为O(n)。

预处理字符串，每个字符中间加上#，并在两边加上^ $，得到
$#a#b#a#^ 可以不用处理边界

拉马车算法的重点在于可以一次性解决某些字母的最长回文串。
有关拉马车的具体时间复杂度:O(n)。
每次保证mx是最远的。

参考链接:<https://segmentfault.com/a/1190000008484167>

P[i]: 0, 1, 2...，表示以i为中心不包括s[i]的半径，回文字符串是 [i-P[i], i+P[i]]

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        s2 = ['$']
        for i in range(n):
            s2.append("#")
            s2.append(s[i])
        s2.append("#")
        s2.append("^")

        m = len(s2)
        P = [0 for _ in range(m)]
        center=1
        mx = 1
        max_id = 1
        for i in range(1, m-1):
            i_mirror = 2*center-i
            if i<=mx:
                P[i] = min(P[i_mirror], mx-i)
            else:
                P[i] = 0
            while s2[i-P[i]-1]==s2[i+P[i]+1]:
                P[i]+=1
            if mx<i+P[i]:
                center = i 
                mx = i+P[i]
            if P[max_id]<P[i]:
                max_id = i 
        start = (max_id-P[max_id]-1)//2
        cur_len = P[max_id]
        res = s[start:start+cur_len]
        return res
# 新字符串 [id-p[id], ..., id, ..., id+p[id]], 且 id-p[id], id+p[id]一定是#
# 对应到旧字符串 [id-p[id]+1, id-p[id]+3... id, ... id+p[id]-1]
# len = ((2*p[id]+1)-1)//2=p[id]
# start = (id-p[id]+1-2)//2 = (id-p[id]-1)//2
# 时间复杂度证明： 只有 p[2*id-1]==mx-i时，才会执行p[i]+=1，且每执行一次 p[i]+=1，mx会加1，即 p[i]+=1的执行次数等于mx的更新次数。mx每次单调递增，0..n，所以p[i]+=1执行n次。时间复杂度 O(n)
# return s[start:start+len]
```

## 6.zig-zag-conversion

之字形，一种是从输入流依次放入输出流，一种是依次遍历输出流，求出输入流的位置。

第一种方法需要借助一个二维列表；第二种方法需要求解公式。

## 8.string-to-integer-atoi

ord(), hex()

32位有符号整数，最小值：0x8000 0000，或者-2**31， 即-2147483648；
最大值：0x7FFFFFFF，或者2**31-1，即2147483647

32位无符号整数，最小值：0x0，即 0；
最大值：0xFFFFFFFF， 即4294967295

re.match() group()  groups() re.search()

## 11.container-with-most-water

最大蓄水问题的证明：<https://blog.csdn.net/kid551/article/details/83094787>

左右两个指针同时夹逼，每次移动最短的边。

属于贪心算法

当取某个最小值并且需要对最小值的位置做进一步处理。6666666

```python
max_area, i, j = max(max_area, h*(j-i)), i+(height[i]==h), j-(height[j]==h)
```

## 15.3-sum

**同一方向的两个指针可以考虑转化为左右两个指针相向而行**.

## 17.letter-combinations-of-a-phone-number

```python
res = reduce(lambda acc, digit: [x+y for x in acc for y in __kvmaps[digit]], digits, [''])

```

## 18.4-sum

```python
findNsum(self, nums, target, N, result, results)
```

result用于记录每次当前的结果，results用于记录当完全成功时的结果，互不影响，互相补充。在22中也用到了。

## 24.swap-nodes-in-pairs

```python
p1.next, p2.next, p3.next = p3, p3.next, p2
p0.next, p1.next, p2.next = p2, p2.next, p1
# or
p2, p3 = p1.next, p1.next.next
p1.next, p2.next, p3.next = p3, p3.next, p2
p1 = p2
```

这里用到的三元素交换巧妙地将每次将p1都放在即将交换的前一位，由三行代码变成了两行

## 29.divide-two-integers

在python中，-7除以3的商和7除以-3比7除以3的商大1.

在c++和java中，-7除以3的商和7除以-3和7除以3的商一致。

## 33.search-in-rotated-sorted-array

在这道题发现自己对于二分法掌握得很不熟练，

对于二分法，

* 循环条件是l<=r
* 循环语句是l=mid+1,r=mid-1
* 结束条件是nums[m]==target

当l和r相差1时，m有两种取法

* m = (l+r)//2，此时m=l，用于寻找相同元素的左边界
* m = (l+r+1)//2，此时m=r，用于寻找相同元素的右边界

```python
# 最基本的
l, r = 0, n-1
while l<=r:
    m = (l+r)//2
    if nums[m] = target:
        break
    if nums[m]<target:
        l=m+1
    else:
        r=m-1
```

```python
# 左右边界
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1, -1]
        res = [-1, -1]
        l, r = 0, len(nums)-1
        while l<=r:
            mid = (l+r)//2
            if l==mid and nums[mid]==target:
                res[0]=mid
                break
            if nums[mid]<target:
                l = mid+1
            elif nums[mid]==target:
                r = mid
            else:
                r = mid-1
        l, r = 0, len(nums)-1
        while l<=r:
            mid = (l+r+1)//2
            if r==mid and nums[mid]==target:
                res[1]=mid
                break
            if nums[mid]<target:
                l = mid+1
            elif nums[mid]==target:
                l = mid
            else:
                r = mid-1
        return res
```

旋转数组的最小值
二分法

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        
        left, right = 0, len(nums)-1
        res = nums[0]
        while left<=right:
            mid = (left+right)//2
            if nums[mid]<=nums[right]:
                res = min(res, nums[mid])
                right = mid-1
            else:
                left = mid+1
        return res
        
        
```



## 36.valid-sudoku

二维列表转置

```python
matrix = [ [row[col] for row in matrix] for col in range(len(matrix[0]))]
# or
matrix = list(map(list, zip(*matrix)))
```

九宫格

```python
x = 3*(i/3)+j/3
y = 3*(i%3)+j%3
```

三进制表示

```python
# 个位
num%3
# 十位
(num//3)%3
# 百位
(num//3//3)%3
# 对于最后一位，则不需要再次取余
```

## 46.permutations

对于迭代返回二维列表的情况，有两种终止条件，一种是判断是否到了结尾，此时返回的单元素的情况，一种是判断是否出了结尾，此时返回的是空元素的情况。

```python
# method 1.0 单元素的情况
class Solution:
    def permute(self, nums):
        # 空元素视为特殊情况
        if not nums:
            return [[]]
        # 单元素返回一个单元素的二维列表
        if len(nums)==1:
            return [nums]
        res = list()

        for i, val in enumerate(nums):
            for permute in self.permute(nums[:i]+nums[(i+1):]):
                res.append([val]+ permute)
        return res

# method 2.0 空元素的情况
class Solution:
    def permute(self, nums):
        # 空元素时返回一维列表，用or语句使p循环时变成二维列表
        # 或者进行一次判断，使空元素返回一个二维列表
        res = []
        for i, n in enumerate(nums):
            print(i,n)
            for p in self.permute(nums[:i]+nums[(i+1):]) or [[]]:
                print(p)
                res.append([n]+p)
        return res

```

## 48.rotate-image

二维列表的转置

```python
matrix
# v1
res = list(map(list, zip(*matrix)))
# v2
res = zip(*matrix)
# v3
res = [[row[i] for row in A] for i in range(len(A[0]))]
```

二维列表的上下颠倒

```python
res = matrix[::-1]
```

二维列表的左右颠倒

没有找到

二维列表的旋转

```python
# v1
res = zip(*matrix[::-1]) # 上下翻转+转置 # 顺时针旋转
# v2
res = zip(*matrix)[::-1] # 转置+上下翻转 # 逆时针旋转
```

**取反操作**.

```python
# 取反操作
~i = -i-1
# matrix = n*n 中心对称
(i, j)-->(n-i-1, n-j-1)==(-i-1, -j-1)==(~i, ~j)
# 90度对称
(i, j)-->(j, -(i+1))-->(-(i+1), -(j+1))-->(-(j+1), i)-->
(i, j)-->(j, ~i    )-->( ~i   , ~j    )-->(~j    , i)
```

## 54.spiral-matrix

**and** 和 **or**

```python
c = (con1 and con2)
c = (con1 or con2)
```

* and返回最后一个为真的值或者第一个为假的值
* or返回第一个为真的值或者最后一个为假的值

这个特性可以用于递归终止

```python
def fun1(self, matrix):
    return matrix and [*matrix.pop[0]] + self.fun1(matrix)
# 等效于
def fun1(self, matrix):
    if not matrix: # 如果为空，则终止
        return matrix
    res = [*matrix.pop[0]] + self.fun1(matrix)
    return res

```

## 55.jump-game

有的时候我们并不需要记录每一个位置的具体情况，而只需要记录某种情况的边界就足够了，从而将一个列表转换为某种情况的最左(右)边界的位置。

## 60.permutation-sequence

这次主要分析一个关于除法的问题

```python
# 除数为6，希望
# 1-->0..1, 2-->0..2, 3-->0..3,
# 4-->0..4, 5-->0..5, 6-->0..6,
# 并且余数也满足这个规则，依次除下去。
# 两种解决方案
# 第一种
while：
    i, k = divmod(k-1, 6)
    k+=1
# 第二种
k-=1
while:
    i, k = divmod(k, 6)
# 思路：将上述的规则转化为：
# 0-->0..0, 1-->0..1, 2-->0..2,
# 3-->0..3, 4-->0..4, 5-->0..5,
# 并且余数也能满足这个规则，依次除下去
# 只是如果需要当前余数的时候，再加1即可
```

## 64.minimum-path-sum

在这里暴露出的问题是当需要一行res进行存储表示且满足:

```python
# res_table 和 res_row
# res_table中的元素满足
# res_table[i][j]=f(res_table[i-1][j], res_table[i][j-1])
# 此时res_table可以弱化为res_row，且res_table可以分为四类
# 第一类：(0,0)
# 第二类：(0,1), (0,2)...
# 第三类：(1,0), (2,0)...
# 第四类：(1,1),...
# 此时可以通过适当的初始化，将第一类和第三类合并成一类，将第二类和第四类合并成一类，即
# 第一类：(0,0), (1,0), (2,0)...f3:res[j]-->res[j]
# 第二类：(0,1), (0,2), (0,3)...f4:res[j],res[j-1]-->res[j]
# 此时res_row[0]服务于第一类，即f3:res[j]-->res[j]
# res_row[1:]服务于第二类，即f4:res[j],res[j-1]-->res[j]

# 如果上述的合并成两类比较困难，可以采用下面一种方法，代码略多一些，但是更清晰一些

res_row = [0 for _ in range(n)]
# 第一类
res_row[0][0]=f1;
# 第二类
for j in range(1,n):
    res_row[j]=f2:res[j-1]-->res[j]
# 第三类和第四类
for i in range(1,m):
    # 第三类
    res_row[0]=f3:res[j]-->res[j]
    for j in range(1,n):
        # 第四类
        res_row[j]=f4:res[j],res[j-1]-->res[j]
# 齐活
```

## 71.simplify-path

这里犯了逻辑错误

* 遇到 '..' , 如果为空，跳过，如果不为空，弹出；
* 遇到 '', '.', 跳过
* 遇到其他字符， 压入

此时可以合并成

* 遇到 '..' 且不为空， 弹出；(先处理特殊情况'..'且不为空)
* 遇到 '', '.', '..', 跳过；
* 遇到其他字符， 压入

## 77.combinations

这里记录一下递归中返回二维列表的处理方法：

```python
# 异常情况，返回一个空一维列表，在for val_list中会被自动忽略，并一直向上返回一个空列表，一直被忽略
if len(n_list)<k:
    return []
# 正常结束情况，返回一个空二维列表，在for val_list中会被自动添加
if k == 0:
    return [[]]
# 递归返回
res = list()
for i, val in enumerate(n_list):
    for val_list in self.combine_list(n_list[i+1:], k-1):
        res.append([val]+val_list)
return res
```

## 79.word-search

这里进行深度遍历的时候碰到了两个问题：

* 第一个：在成功时如何快速结束： 用 or ，当成功时，后面的都不会进行 
* 第二个：如何判断这个数字是否已经取过： 取过之后变成#，奸诈，在search之后再变回来

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        m = len(board)
        n = len(board[0])
        word = list(word)
        k = len(word)
        def search(idx, i, j):
            if idx == k:
                return True
            if i<0 or i==m or j<0 or j==n:
                return False
            if word[idx] != board[i][j]:
                return False
            board[i][j]='#'
            res = search(idx+1, i+1, j) or \
                search(idx+1, i, j+1) or \
                search(idx+1, i-1, j) or \
                search(idx+1, i, j-1)
            board[i][j]=word[idx]
            return res
        for x in range(m):
            for y in range(n):
                if search(0, x, y):
                    return True
        return False
```

## 82.remove-duplicates-from-sorted-list-ii

这个递归的思路之前都没有见过，而且处理头指针的方法也不太一样，是直接返回的，而没有用pHead进行标记

```python
class Solution(object):
    def deleteDuplicates(self, head):
        return self.h(head)

    def h(self, head):
        if not head or not head.next: return head
        if head.val != head.next.val:
            head.next = self.h(head.next)
            return head
        x = head.val
        cur = head.next
        while cur and x == cur.val:
            cur = cur.next
        return self.h(cur)
```

```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        if not head:
            return head
        cur, is_head = head.next, False
        while cur and cur.val == head.val:
            cur = cur.next
            is_head = True
        head.next = self.deleteDuplicates(cur)
        return head.next if is_head else head
```

## 78, 90 subset

求子集的dfs大法，原理对当前位置的可能性：[], nums[i], nums[i+1], ... nums[-1]

```python
class Solution:
    def subsetsWithDup(self, nums):
        nums.sort()
        res = []
        def dfs(index, path):
            res.append(path)
            for i in range(index, len(nums)):
                if i>0 and nums[i]==nums[i-1]:
                    continue
                dfs(i+1, path+[nums[i]])
        dfs(0, [])
        return res
```

## 91.decode-ways

对于简单地重复从一个序列中依次取出元素做某个操作，可以考虑用reduce和map,

自己在这方面的意识还不是很强

```python
from functools import reduce
class Solution:
    def numDecodings(self, s: str) -> int:
        def func(x1, d):
            v, w, p = x1
            v, w, p = w, (d>'0')*w+(9<int(p+d)<27)*v, d
            return (v, w, p)
        return reduce(func,s,(0,s>'',''))[1]
```

## 92.reverse-linked-list-ii

翻转列表

p3指向当前节点，p2指向前一个节点，为了p3.next指向成功，p4指向后一个节点，为了不被断掉

```python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        if (not head) or m==n:
            return head
        pHead = ListNode(0)
        pHead.next = head
        p1 = pHead
        for i in range(m-1):
            p1 = p1.next
        p1_prev, p1 = p1, p1.next
        p2, p3, p4 = p1_prev, p1_prev.next, p1_prev.next.next
        for i in range(n-m):
            p2, p3, p4 = p3, p4, p4.next
            p3.next = p2
        p1_prev.next, p1.next = p3, p4
        return pHead.next
```

## 93.restore-ip-addresses

这里有个逻辑判断写的挺好

* 如果a=1，那么可以
* 如果a>1，那么首位不能为0才可以

```python
# 我写出来的逻辑
a==1 or (a!=1 and s[0]!='0')
# 作者写出来的逻辑
a==1 or s[0]!='0'
# 当然在推论上两者是等价的，怎么才能一下子想到这种写法
# 自己应该注意一下这种写法
# 或者说or本身就有否定前者的含义，因此在否定前者的时候，可以不用明确写出
```

## 94.binary-tree-inorder-traversal

这道题涉及到了二叉树遍历的递归和循环两种方法，现在只是有点模糊的递归和循环转换方法。

参考链接:<https://www.cnblogs.com/bjwu/p/9284534.html>

核心思想：

* 栈stack表示cur之前的递归路径，cur表示当前的递归体
* 进入递归表示入栈(cur有值)，返回函数表示出栈(cur=None)
* 可以通过模拟递归的方法来模拟出入栈的思路
* 当前循环体有三种操作：入栈、出栈、操作
* 可以基本证明：如果某次入栈出栈后没有其余多余操作时，总是可以省略的，但是具体的省略方法还没有统一。

**中序遍历**：
递归1：

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right)  
```

递归2：

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        def helper(root):
            if not root:
                return
            helper(root.left)
            res.append(root.val)
            helper(root.right)
        helper(root)
        return res
```

循环:

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack = []
        res = []
        cur = root
        while cur or stack:
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right
        return res
```

联想到Morris循环，这里貌似有一些相似，cur为空表示cur的左子树已经遍历结束。算了，不想了，太乱了。

**前序遍历**：
递归：

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        return [root.val]+self.preorderTraversal(root.left)+self.preorderTraversal(root.right)  
```

循环1：

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack = []
        res = []
        cur = root
        while cur or stack:
            if cur:
                res.append(cur.val)
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                cur = cur.right
        return res
```

循环2：我只能说是对的，但是怎么推导过来的不清楚，难道是循环1的精简版？感觉像

刚刚想了想循环2的实现原理，不仅仅是精简版那么简单，更像是因为当前循环体的操作在入栈之前，所以当进入下一个循环体后就没有必要再将当前循环体压入栈中，只要保证下一个循环体返回后，出栈的是应该进入的循环体(即右子节点即可)

```python
class Solution:
    def preorderTraversal(self, root):  ## 前序遍历
        stack = []
        sol = []
        curr = root
        while stack or curr:
            if curr:
                sol.append(curr.val)
                stack.append(curr.right)
                curr = curr.left
            else:
                curr = stack.pop()
        return sol

# 或者是  DFS
def preorderTraversal(root):
    stack = [root]
    res = list()
    while stack:
        cur = stack.pop()
        if cur:
            res.append(cur)
            stack.append(cur.left)
            stack.append(cur.right)
```

**后序遍历**：
递归：

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        return self.postorderTraversal(root.left)+self.postorderTraversal(root.right)+[root.val]
```

循环1：

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        res = list()
        stack1 = list()
        stack2 = list()
        cur = root
        while cur or stack1:
            if cur:
                stack1.append(cur)
                stack2.append(0)
                cur = cur.left
            else:
                cur, id = stack1.pop(), stack2.pop()
                if id==0:
                    stack1.append(cur)
                    stack2.append(id+1)
                    cur = cur.right
                elif id == 1:
                    res.append(cur.val)
                    cur = None
```

循环2：好吧，左右中等于中右左，等效于前序遍历，这我无话可说

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        stack = list()
        res = list()
        cur = root
        while stack or cur:
            if cur:
                res.append(cur.val)
                stack.append(cur.left)
                cur = cur.right
            else:
                cur = stack.pop()
        return res[::-1]
```

**层次遍历**：

层次遍历的递归循环转换规则和上述不太一样，不可直接套用

递归： 层次遍历用递归，没想过hhh

```python
# 层次遍历
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        def helper(node, level):
            if not node:
                return
            else:
                sol[level-1].append(node.val)
                if len(sol) == level:  # 遍历到新层时，只有最左边的结点使得等式成立
                    sol.append([])
                helper(node.left, level+1)
                helper(node.right, level+1)
        sol = [[]]
        helper(root, 1)
        return sol[:-1]
```

zigzag:

```python
# zigzag
class Solution:
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        def helper(node, level):
            if not node:
                return
            else:
                if level%2==1:
                    sol[level-1].append(node.val)
                else:
                    sol[level-1].insert(0, node.val)
                if len(sol) == level:  # 遍历到新层时，只有最左边的结点使得等式成立
                    sol.append([])
                helper(node.left, level+1)
                helper(node.right, level+1)
        sol = [[]]
        helper(root, 1)
        return sol[:-1]
```

循环：

```python
# 层次遍历
class Solution:
    def levelOrder(self, root):
        if not root:
            return []
        sol = []
        curr = root
        queue = [curr]
        while queue:
            curr = queue.pop(0)
            sol.append(curr.val)
            if curr.left:
                queue.append(curr.left)
            if curr.right:
                queue.append(curr.right)
        return sol
```

zigzag:

```python
# zigzag
class Solution:
    def levelOrder(self, root):
        if not root:
            return []
        sol = []
        curr = root
        stack1 = [curr]
        stack2 = []
        while stack1 or stack2:
            if stack1:
                cur = stack1.pop()
                sol.append(cur.val)
                if cur.left:
                    stack2.append(cur.left)
                if cur.right:
                    stack2.append(cur.right)
            else:
                cur = stack2.pop()
                sol.append(cur.val)
                if cur.right:
                    stack1.append(cur.right)
                if cur.left:
                    stack1.append(cur.left)
        return sol
```

**Morris Traversal**:非递归，不用栈，O(1)空间复杂度，核心思想是怎么找到下一个输出的结点

二叉树递归遍历的实质是，只要这个节点不为空，那么这个节点一定会遍历3次，先序中序后续只不过是打印的时机不同。先序是第一次到达这个节点，中序是第二次，后序是第三次。Morris遍历高度模仿这个过程。Morris遍历，如果这个节点有左子树，那么能到达这个节点两次，没有左子树，只能到达这个节点一次。

<http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html>

```python
# tree
#        1
#      /   \
#     2      3
#   /   \  /   \
#  4    5  6    7
```

**中序遍历**：

* 如果cur的左孩子为空，输出cur并cur=cur.right
* 如果cur的左孩子不为空，则找到cur的前驱结点pre(一定在左子树中)
* * 如果前驱结点pre的右孩子为空，则pre.right = cur,cur = cur.left
* * 如果前驱结点的右孩子为当前节点pre.right==cur，则pre.right=None,输出cur，cur=cur.right

中序遍历的方法：a)当左子树不为空且没有被访问时，遍历左子树，设置cur的前驱结点为左子树的尾节点,左子树遍历之后cur指向左子树的尾节点，当左子树为空或者已经被访问(pre.right==cur)时，遍历右子树cur=cur.right，右子树遍历之后cur指向右子树的尾节点;b)并且当左子树为空或者已经被访问(pre.right==cur)时，输出cur

公式:$f(T(1))=f(T(2))+T(2)->1+f(T(3))$

其中f定义为root的中序输出，T(2)->1时(左子树为空或者已经被访问)输出cur

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        cur = root
        res = list()
        while cur:
            if not cur.left:
                res.append(cur.val)
                cur = cur.right
            else:
                pre = cur.left
                while pre.right and pre.right!=cur:
                    pre = pre.right
                if not pre.right:
                    pre.right = cur
                    cur = cur.left
                else:
                    res.append(cur.val)
                    pre.right = None
                    cur = cur.right
        return res
```

时间复杂度分析：O(n)，n个点，n-1条边，点最多访问两次(while cur)，边最多访问两次(while pre.right and pre.right!=cur)

**前序遍历**：

核心分析与中序遍历类似，令cur.right指向下一个要访问的结点

* 如果cur.left为空，则输出cur并cur=cur.right
* 如果cur.left不为空，找到左子树的前驱结点pre
* * 如果pre.right为空，则pre.right=cur，输出cur，cur=cur.left
* * 如果pre.right不为空，则pre.right=None, cur=cur.right

前序遍历：a)当左子树不为空且没有被访问时，遍历左子树，设置cur的前驱结点为左子树的尾节点，左子树遍历之后的cur指向左子树的尾节点，当左子树为空或者已经被访问(pre.right==cur)时，遍历右子树cur=cur.right，右子树遍历之后cur指向右子树的尾节点;b)并且当左子树为空或者没有被访问(pre.right==None)时，输出cur

公式:$f(T(1))=T(2)->1+f(T(2))+f(T(3))$

其中f定义为root的前序输出，T(2)->1(当左子树为空或者没有被访问)输出cur

```python
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        cur = root
        res = list()
        while cur:
            if not cur.left:
                res.append(cur.val)
                cur = cur.right
            else:
                pre = cur.left
                while pre.right and pre.right!=cur:
                    pre = pre.right
                if not pre.right:
                    res.append(cur.val)
                    pre.right = cur
                    cur = cur.left
                else:
                    pre.right = None
                    cur = cur.right
        return res
```

**后序遍历**：

后序遍历有点坑啊，公式总结了两天才得到

* 建立临时结点dump，令其左孩子是root
* 如果cur的左孩子为空，cur=cur.right
* 如果cur的左孩子不为空，则找到cur的前驱结点pre(一定在左子树中)
* * 如果前驱结点pre的右孩子为空，则pre.right = cur,cur = cur.left
* * 如果前驱结点的右孩子为当前节点pre.right==cur，则pre.right=None,倒序输出从cur.left到pre的所有结点(即cur.left 一路right到pre)

后序遍历的方法：a)当左子树不为空且没有被访问时，遍历左子树，设置cur的前驱结点为左子树的尾节点，左子树遍历之后cur指向左子树的尾节点，当左子树为空或者已经被访问(pre.right==cur)时，遍历右子树cur=cur.right，右子树遍历之后cur指向右子树的尾节点;b)当cur的左子树遍历之后，倒序输出cur.left到pre的结点

后序遍历的输出

公式:$f(T(0))=f(T(1))+f(T(3))+f(T(7))+T(7)-->0$

其中f定义为root的左子树的后序输出，T(7)-->0时倒序输出，可以简单证明这种方法是正确的。

```python
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        dump = TreeNode(0)
        dump.left = root
        cur = dump
        res = list()
        def reverse(begin, end):
            res_tmp = list()
            cur_tmp = begin
            while begin!=end:
                res_tmp.append(begin.val)
                begin = begin.right
            res_tmp = res_tmp[::-1]
            return res_tmp
        while cur:
            if not cur.left:
                cur = cur.right
            else:
                pre = cur.left
                while pre.right and pre.right!=cur:
                    pre = pre.right
                if not pre.right:
                    pre.right = cur
                    cur = cur.left
                else:
                    res.extend(reverse(cur.left, pre))
                    pre.right = None
                    cur = cur.right
        return res
```

同时可以看到中序、前序、后序三种输出方式的cur的转移方式是一样的，不一样的是何时以哪种方式输出。

* 中序: 左子树为空或者已经被遍历，输出cur
* 前序: 左子树为空或者还没有被遍历，输出cur
* 后序: 左子树已经被遍历，倒序输出cur.left--pre

## 95.unique-binary-search-trees-ii

二叉搜索树：中序遍历是有序的

## 96.unique-binary-search-trees

感觉到了这里，已经不能用简单的递归之类的算法来解决了，都或多或少地涉及到一些额外的知识。

**卡特兰数**：

参考链接:<https://blog.csdn.net/wookaikaiko/article/details/81105031>

1, 1, 2, 5, 14, 42, 132

实在总结不出来就看前三项是否满足1,1,2,5或者1,2,5这样的顺序

公式：$h(n)$

$$h(0)=1, h(1)=1$$
$$h(n)=h(0)h(n-1)+h(1)h(n-2)+...+h(n-1)h(0) (n>=2)$$
或者
$$h(n)=C(2n,n)-C(2n,n+1) (n=0,1,...)$$
或者
$$h(n)=\frac{C(2n,n)}{n+1}$$
或者
$$h(n)=\frac{1}{n+1}*\sum_{i=0}^n(C_n^i)^2$$
或者
$$h(n+1)=\frac{2(2n+1)}{n+2}h(n)$$

**规律1，进出栈形式** 根据格子和5元10元问题，暂时可以发现这两道题的一个规律进出栈，a) 起终都是为空(到中线/没有5元)b) 中间过程中有值时，两个操作AB都可以进行(向左或者右走/5元或者10元)， c) 中间过程中为空(即到中线/没有5元)时，只能执行操作A(向右走/5元)，d)先操作A后操作B等效于空

**规律2，相互独立形式** 是根据三角形划分等问题得到的，n个点，确定点j后，问题可以划分为两个相互独立的子问题(j-1个点和n-j-1个点)，并且j的取值范围是0->n-1.

应用：

**进出栈问题**：进栈序列为1,2,3,...,n时有多少个不同的出栈序列？

定义h(n)是n个数字的不同的出栈序列个数。假设k是最后一个出栈的数字，那么比k早进早出栈的有k-1个数，即出栈的前k-1个数的集合为{1,2,...,k-1}，比k晚进早出栈的有n-k个数，即出栈序列的后n-k个数的集合是{k+1,k+2,...,n}，所以此时总体出栈序列为{1,2,...,k-1},{k+1,k+2,...,n},k,且前半段和后半段相互独立，k可以从1取到n，所以有$h(n)=h(0)h(n-1)+h(1)h(n-2)+...+h(n-1)h(0)$

**进出栈问题的变种**：n个人拿5元、n个人拿10元买物品，物品5元，老板没零钱，问有几种排队方式。可以将其转换为拿5元的人表示入栈，拿10元的人表示出栈，所以排队顺序就等于出栈顺序，即h(n)种，又因为n个人不同，有n种排列，所以总排队方式有h(n)n!n!种。

**n个不同结点的二叉搜索树或者n个相同结点的二叉树构成问题**：n个结点1~n，一共可以构成几种二叉搜索树。

如果采用中序遍历的话，假设根节点第k个被访问，则根节点的左子树有k-1个结点，即集合{1,2...k-1}，右子树有n-k个结点，即集合{k+1,...,n}，且互相独立。

n个不同结点的二叉搜索树和n个相同结点的二叉树是一一对应的，只要令二叉树的中序遍历的结点重新从小到大赋值，就是n个不同结点的二叉搜索树。

**凸多边形的三角形划分**：一个凸的n边形，用直线连接他的两个顶点使之分成多个三角形，每条直线不能相交，问一共有多少种划分方案。

![三角划分](./fig/96_sanjiao.jpg)

选择一条基边，假设是p1-pn，再选择另外一个点pi做一个三角形，那么除了中间的三角形之外，K2是i边多边形，K1是n-i+1边多边形，i的取值范围是2到n-1，所以C(n)=C(2)C(n-1)+...C(n-1)C(2)，令h(n)=C(n+2)，所以h(n)=h(0)h(n-1)+h(1)h(n-2)+...+h(n-1)h(0)，且C(n)=h(n-2)

**n+1个叶子结点的满二叉树(国外定义，度或者为0，或者为2)的个数**：

事实上，向左记为+1，向右记为−1，按照中序遍历(不遍历root)向左优先的原则，从根节点开始遍历．例如第一个图记为+1,+1,+1,−1,−1,−1,于是由卡特兰数的含义可得满二叉树的个数为h(n)。

![满二叉树](./fig/97_binary_tree.png)

**nxn格子的走法**：nxn格子中，只能下三角行走，每次横走或者竖走一格，有多少种走法？

![nxn格子图](./fig/96_grid.png)

令向右走相当于进栈，向左走相当于出栈。

至于这样的规律是否一定可以满足出入栈的解法，还有待验证。

**凸n+2边形区域分成三角区域的方法<=>n+1个叶子结点的满二叉树的类型<=>n+1个数连乘的乘法顺序**.

**引理1**：由n对括号形成的合法括号表达式的个数为h(n).

这个n对括号等同于刚刚满二叉树的+1和-1记为左括号和右括号。

这个有点复杂，写不清楚，就直接套用作者的话吧

![括号](./fig/96_kuohao.png)

**引理2**：n+1个数连乘，不同的乘法顺序数为h(n)。

凸n+2边形转化为n+1个数字的乘法顺序

![多边形转化为n+1个数字的乘法方法](./fig/97_duobianxing.png)

**圆上2n个点的连接方法**：在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数？和凸包切割一个原理

![圆上2n个点的连接方法](./fig/97_yuanqiege.png)

那里不是减号，而是等于号。

**n个长方形填充阶梯图**：n个长方形填充一个高度为n的阶梯状图形的方法个数？把包含左上角的矩形去掉，就很容易由递推公式二推得所有填充方法数就是卡特兰数。

![n个长方形填充阶梯图](./fig/97_stairsteps.png)

## 105 & 106 construct-binary-tree-from-inorder-and-postorder-traversal

在有中序遍历的情况下，前序/后序遍历的作用是一样的，每次弹出的结点都是当前树的根节点。

```python
# 105
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not inorder:
            return 
        ind = inorder.index(preorder.pop(0))
        root = TreeNode(inorder[ind])
        root.left = self.buildTree(preorder, inorder[:ind])
        root.right = self.buildTree(preorder, inorder[ind+1:])
        return root

# 106
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        if not inorder or not postorder:
            return None
        ind = inorder.index(postorder.pop())
        root = TreeNode(inorder[ind])
        root.right= self.buildTree(inorder[ind+1:], postorder)
        root.left = self.buildTree(inorder[:ind], postorder)
        return root
```

## 109.convert-sorted-list-to-binary-search-tree

平衡二叉搜索树的链表等于中序遍历，或者说，给定一个中序遍历，怎么得到二叉树。

```python
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        r = -1
        node = head
        while node:
            r+=1
            node = node.next
        node = head
        def Lrt2BST(l, r):
            # 空 结束条件
            nonlocal head
            if l>r:
                return None
            mid = (l+r)//2
            left = Lrt2BST(l, mid-1)
            root = TreeNode(head.val)
            head = head.next
            right = Lrt2BST(mid+1, r)
            root.left = left
            root.right = right
            return root
        root = Lrt2BST(0, r)
        return root
```

## 程序员代码面试指南

### 打气球的最大分数

这个题很有意思，不同于一般的动态规划的定义。

定义 dp[i][j]:表示 i-1, j+1 位置有气球时 i-j 的最大分数，通过最后一个打爆的气球进行动态规划。

```python
def demo1(n, arr):
    Matrix = [[0 for _ in range(n+2)] for _ in range(n+2)]
    for i in range(1, n+1):
        Matrix[i][i]=arr[i-1]*arr[i]*arr[i+1]
    # print(Matrix)
    for i in range(n-1, 0, -1):
        for j in range(i+1, n+1):
            for k in range(i, j+1):
                Matrix[i][j] = max(Matrix[i][j], Matrix[i][k-1]+Matrix[k+1][j]+arr[i-1]*arr[k]*arr[j+1])
    # print(Matrix)
    return Matrix[1][n]


if __name__=='__main__':
    n = int(input())
    arr = [1]+list(map(int, input().split()))+[1]
    res = demo1(n, arr)
    print(res)

```

### 合并排序

数组的小和

### 单调栈/单调队列

#### 设计 getMin 功能的栈

用 h[i]=max(arr[i], h[i-1]) 记录0-i的最小元素

```python
class StackDemo():
    def __init__(self):
        self.stack = list()
        self.stack_min = list()
    def push(self, value):
        self.stack.append(value):
        if len(self.stack_min)==0 or self.stack_min[-1]>=value:
            self.stack_min.append(value)
        else:
            self.stack_min.append(self.stack_min[-1])
    def pop(self,):
        if not self.stack:
            return None
        self.stack_min.pop()
        res = self.stack.pop()
        return res
    def getMin(self):
        if not self.stack:
            return None
        res = self.stack[-1]
        return res
```

#### 直方图最大矩形面积

单调栈h，矩形的高度从小到大，
arr[i]>=h.top()，压入，
arr[i]< h.top()，弹出，并计算面积，此时矩形的右边界是i-1，左边界是h.top（或者是0），高度是h[0]

stack=[-1]保持stack内总是有元素的且总有元素是小于任何一个位置的，方便当stack内只剩下来自heights的
一个元素时，计算w,选用-1 是因为，heights中的元素都是非负的，所以左侧用-1 就可以保证是一个小于所有heights
内元素的值
2.heights.append(0)，保持heights中最末尾总有一个小于所有元素的，这样才可以在heights都append到stack后
通过最末尾的这个0将stack中剩下的元素对应的面积全部求出来，

```python
def largestRectangleArea(heights):
    heights.append(0)
    stack = [-1]
    res = 0
    for i in range(len(heights)):
        while heights[i]<heights[stack[-1]]:
            index = stack.pop()
            h = heights[index]
            w = i-stack[-1]-1
            res = max(res, h*w)
        stack.append(i)
    heights.pop()
    return res
```

#### 0-1矩阵1组成的最大矩形面积

对列求和，转化成直方图最大矩形面积

#### 0-1矩阵, 1构成的最大联通区域面积

#### 221 0-1矩阵, 1构成的最大正方形面积

dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1; where matrix[i][j] == 1

https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/solution/tong-ji-quan-wei-1-de-zheng-fang-xing-zi-ju-zhen-2/

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        n, m = len(matrix), len(matrix[0])
        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
        res = 0
        for i in range(1, n+1):
            for j in range(1, m+1):
                if matrix[i-1][j-1]=="1":
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])+1
                    res = max(res, dp[i][j])
        # print(dp)
        return res*res
```

#### 最大蓄水面积

left > right: 计算面积，right--
left < right: 计算面积，left--

#### 雨水收集面积

LeftMostHeight, RightMostHeight

```python
LeftMostHeight = max(arr[i], LeftMostHeight)
RightMostHeight = max(arr[j], RightMostHeight)
if LeftMostHeight<RightMostHeight:
    res+=(LeftMostHeight-arr[i])
    i+=1
else:
    res+=(RightMostHeight-arr[j])
    j-=1
```

#### 滑动窗口最大值

单调队列h 记录i-w~i的从大到小的元素
arr[i]<=h.end()，压入
arr[i]> h.end()，弹出
h.start()>w，弹出

```python
def maxSlidingWindow(nums, k):
    if k==1:
        return nums
    if not nums:
        return []
    if k>len(nums):
        return max(nums)
    n = len(nums)
    maxqueue = list()
    res = list()
    for i in range(n):
        # 滑动窗口外
        if maxqueue and i-k>=maxqueue[0]:
            maxqueue.pop(0)
        # 单调队列
        while maxqueue and nums[i]>nums[maxqueue[-1]]:
            maxqueue.pop()
        # 记录的是位置，用于判断是否在滑动窗口外
        maxqueue.append(i)
        if i >=k-1:
            res.append(nums[maxqueue[0]])
```

#### 最长递增子序列/最长上升子序列 (LIS)



### 最长公共子序列/最长公共子串

f(n, m)=
f(n-1, m-1)+1, if arr1[n]=arr2[m]
max(f(n, m-1), f(n-1, m)), if arr1[n]!=arr2[m]

f(n, m)=
f(n-1, m-1)+1, if arr1[n]=arr2[m]
0, if arr1[n]!=arr2[m]

### 最长不重复子串

https://blog.csdn.net/zw159357/article/details/79644944

```python
import java.util.*;
public class A {
    public static void main(String[] args) {
    Scanner in=new Scanner(System.in);
    String s="";
    s=in.nextLine();
    char[] c=new char[256];
    int[] charMap=new int[256];      //记录重复字母的下标
    c=s.toCharArray(); 
    Arrays.fill(charMap,-1);        //初始化为-1,表示没有找到重复的字母
    int max=0;
    int left=0;                     //left用来记录出现重复字母右边的那一个字母位置
    for(int i=0;i<s.length();i++) {
        //找到了重复的字母，记录位置
        if(charMap[c[i]]>=left) {
            left=charMap[c[i]]+1;
        }
        //计算出此时不重复子串的长度
        int tmp=i-left+1;
        if(tmp>max)
            max=tmp;
        //改变记录的位置
        charMap[c[i]]=i;
    }
    System.out.println(max);
}
```

### 数组排序之后相邻数的最大差值

无序数组的最大差值

解法一：

桶排序思路，N个数N+1桶，记录每个桶的最大最小值，区间为 $\frac{max-min}{N}$


桶内：$<\frac{max-min}{N}$
空桶前后: $>\frac{max-min}{N}$
其他桶前后: $[0, 2*\frac{max-min}{N})$

所以相邻数的最大差值一定来自桶的前后差值

```python
def maxGap(nums):
    if not nums or len(nums)<=2:
        return 0
    n = len(nums)
    min_val = min(nums)
    max_val = max(nums)
    if min_val == max_val:
        return 0
    hasNum = [False for _ in range(n+1)]
    maxs = [0 for _ in range(n+1)]
    mins = [0 for _ in range(n+1)]
    def bucket(nums[i]):
        return int((num-min)*n/(max-min))
    for i in range(n):
        bid = bucket(nums[i])
        if hasNum[bid]:
            maxs[bid] = max(maxs[bid], nums[i])
            mins[bid] = min(mins[bid], nums[i])
        else:
            maxs[bid], mins[bid] = nums[i], nums[i]
        hasNum[bid]=True
    lastmax = maxs[0]
    res = 0
    for i in range(1, n+1):
        if hasNum[i]:
            res = max(res, mins[i]-lastmax)
            lastmax = maxs[i]
    return res

```

解法二：

N个数，有N-1个gap，所以$maxgap>=\frac{max-min}{N-1}$。分为N个桶，$delta=\frac{max-min}{N-1}$

桶内 < delta
桶间 [0, 2 * delta]
只需要比较桶间即可

```python
import sys
class bucket:
    def __init__(self, used=False, min_val=sys.maxsize, max_val=0):
        self.used = used
        self.min_val = min_val
        self.max_val = max_val

class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        if (not nums) or len(nums)<2:
            return 0
        
        max_val = max(nums)
        min_val = min(nums)
        n = len(nums)
        delta = (max_val-min_val)/(n-1)
        buckets = [bucket() for _ in range(n)]
        
        if delta==0:
            return 0
        
        for val in nums:
            idx = int((val-min_val)/delta)
            buckets[idx].used=True
            buckets[idx].min_val = min(buckets[idx].min_val, val)
            buckets[idx].max_val = max(buckets[idx].max_val, val)
        
        lastmax = min_val
        res = 0
        for i in range(n):
            if buckets[i].used:
                # print(i, buckets[i].used, buckets[i].min_val, buckets[i].max_val)
                res = max(res, buckets[i].min_val-lastmax)
                lastmax = buckets[i].max_val
        return res
```

基数排序

```python
class Solution:
    # @param num, a list of integer
    # @return an integer
    def maximumGap(self, num):
        if len(num) < 2:
            return 0
        num = self.radixSort(num)
        res = 0
        for i in range(1, len(num)):
            res = max(num[i] - num[i - 1], res)
        return res
    
    def radixSort(self, num):
        for i in range(31):
            onebucket = []
            zerobucket = []
            needle = 1 << i
            for j in range(len(num)):
                if num[j] & needle != 0:
                    onebucket.append(num[j])
                else:
                    zerobucket.append(num[j])
            num = []
            num += zerobucket
            num += onebucket
        return num
```

### 矩阵中最大子矩阵的和

先对每行按列依次求和
然后固定第 i 列， 第j列，从上到下按照一维求和公式进行求和

### 抛掷硬币，连续出现n次正面的次数期望

设 T(n) 为连续n次正面的平均次数，假设已经投掷 T(n-1)次，出现了n-1次正面，再投一次，如果出现正面，结束，如果出现反面，重新开始

$T(n) = T(n-1)+1+0.5*0+0.5*T(n-1)$

$T(n)=2^{n+1}-2$

特殊地，连续两次正面的次数期望E
$E=0.5*(1+E)+0.25*(2+E)+0.25*2$



### 动态规划的空间复杂度是O(n)

```python
for i in range(1, n1+1):
    last_next = Mat[0]
    Mat[0] = i*dc
    for j in range(1, n2+1):
        last_cur, last_next = last_next, Mat[j]
```

用 last 保留要修改的数字，cur用于后续的计算

### 龙与地下城游戏问题

dp[i][j] 表示从(i,j)出发到终点所需的最少血量
dp[i][j]+map[i][j]>= dp[i+1][j] or dp[i][j+1] 
and dp[i][j]>=1
所以：dp[i][j]=max(min(dp[i+1][j], dp[i][j+1])-map[i][j], 1)

$[[7, 5, 2], [6, 11, 5], [1, 1, 6]]$

### 两个队列实现一个栈

输入队列、输出队列，

弹出：输入队列的队尾元素为弹出值，将其他元素弹出到输出队列，同时输入队列和输出队列互换身份
输出队列总为空

```python
class Stack():
   def __init__(self):
        self.queue1 = list()
        self.queue2 = list()
    def push(self, node):
        self.queue1.append(node)
    def pop(self):
        if len(self.queue1)==0:
            return None
        while len(self.queue1)!=1:
            self.queue2.append(self.queue1.pop(0))
        self.queue1, self.queue2 = self.queue2, self.queue1
        return self.queue2.pop()
```

### 两个栈实现一个队列

输入栈stack1、输出栈stack2

弹出：如果弹出栈为空，则将输入栈的元素弹出到弹出栈

```python
class Queue():
    def __init__(self):
        self.stack1 = list()
        self.stack2 = list()
    def push(self, node):
        self.stack1.append(node)
    
    def pop(self):
        if len(self.stack1)==0 and len(self.stack2)==0:
            return None
        if len(self.stack2)==0:
            while len(self.stack1)>0:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()

```

### 带max函数的队列

滑动窗口求最大值的队列，滑动窗口的右边界是新增加的值，左边界是弹出的值

```python
class MaxQueue:

    def __init__(self):
        self.queue = list()
        self.help = list()

    def max_value(self) -> int:
        return self.help[0] if self.help else -1


    def push_back(self, value: int) -> None:
        while self.help and self.help[-1] < value:
            self.help.pop()
        self.queue.append(value)
        self.help.append(value)

    def pop_front(self) -> int:
        if not self.queue:
            return -1
        res = self.queue.pop(0)
        # 判断最大值出界
        if res == self.help[0]:
            self.help.pop(0)
        return res
```

### 两个有序数组的中位数/两个有序数组的第k大的数字

```python
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        self.n1 = len(nums1)
        self.n2 = len(nums2)
        self.nums1 = nums1
        self.nums2 = nums2
        k1 = (self.n1+self.n2+1)//2
        k2 = (self.n1+self.n2+2)//2
        print(k1, k2)
        mid1 = self.findM(0, 0, k1)
        mid2 = self.findM(0, 0, k2)
        print(mid1, mid2)
        return (mid1+mid2)/2

    def findM(self, start1, start2, k):
        # print(start1, start2, k)
        if start1>=self.n1:
            return self.nums2[start2+k-1]
        if start2>=self.n2:
            return self.nums1[start1+k-1]
        if k==1:
            return min(self.nums1[start1], self.nums2[start2])
        nums1_k = min(k//2, self.n1-start1)
        nums2_k = min(k-nums1_k, self.n2-start2)
        # print(start1+nums1_k-1, start2+nums2_k-1)
        if self.nums1[start1+nums1_k-1]<self.nums2[start2+nums2_k-1]:
            return self.findM(start1+nums1_k, start2, k-nums1_k)
        else:
            return self.findM(start1, start2+nums2_k, k-nums2_k)
```

证明：A[start1+num1_k-1]<B[start2+num2_k-1]时，对于A[start1+num1_k-1]，小于A[start1+num1_k-1]的数字最多有 num1_k-1+num2_k-1<=k-2 (num1_k+num2_k<=k) 个，所以A[start1+num1_k-1]一定小于整体数组的第k小的数字，所以可以删掉 A[start1....start1+num1_k-1]

### 最长回文子串（连续）和最长回文子序列

上文中的拉马车算法：最长回文子串

动态规划解决：

定义f(i,j)表示 子串[i,j]的回文长度
最长回文子串的算法：
if arr[i]==arr[j], f(i,j)=f(i+1, j-1)+2
else: f(i,j)=0
最长回文子序列：
if arr[i]==arr[j], f(i,j)=f(i+1, j-1)+2
else: f(i,j)=max(f(i+1, j), f(i, j-1))

### 上下级参加舞会？？？

这些人之间存在上下级关系，如果一个人的上级来了他就不来，求使得参加舞会人数最多的方案

### 矩阵中最长子序列

```java
int x_1[4] = { 1, -1, 0, 0 };
int y_1[4] = { 0, 0, -1, 1 };

int dfs(vector<vector<int>>& matrix,int rows,int cols,
    int row, int col, vector<vector<int>>&dp)
{
    if (dp[row][col])
        return dp[row][col];
    int maxDepth = 1;
    for (int i = 0; i < 4; ++i)
    {
        int x = row + x_1[i];
        int y = col + y_1[i];
        if (x < 0 || y < 0 || x >= rows
            || y >= cols || matrix[x][y] <= matrix[row][col])
            continue;
        int len = dfs(matrix, rows, cols, x, y, dp) + 1;
        if (maxDepth < len)
            maxDepth = len;
    }
    dp[row][col] = maxDepth;
    return maxDepth;
}
 
int longestIncreasingPath(vector<vector<int>>& matrix) 
{
    if (matrix.empty())
        return 0;
    int rows = matrix.size();
    int cols = matrix[0].size();
    vector<vector<int>> dp(rows, vector<int>(cols, 0));
    int maxDepth = 1;
    for (int i = 0; i < rows; ++i)
    {
        for (int j = 0; j < cols; ++j)
        {
            int tmp = dfs(matrix,rows,cols, i, j, dp);
            if (maxDepth < tmp)
                maxDepth = tmp;
        }
    }
    return maxDepth;
```

### hashtable, hashmap, ConcurrentHashMap

参考链接：
https://www.cnblogs.com/lantianxun/p/8549677.html
https://www.cnblogs.com/skywang12345/p/3310835.html
https://www.cnblogs.com/heyonggang/p/9112731.html

疑问：为什么装载因子是0.75

泊松分布可以确定正常情况下，链表的长度大于等于8的概率很低
但是特殊情况下，比如有人刻意攻击你的hashmap，为了保证查询和插入的速度还是很快，就会将链表转换为红黑树（比较平衡）

装载因子=0.75是经验确定，基本在0.6-0.8

### 莫队算法

参考链接：https://www.myblog.link/2016/01/26/MO-s-Algorithm/
https://www.cnblogs.com/WAMonster/p/10118934.html

离线求M个[L,R]中不同元素的个数

```python
import functools
class Solu():
    def __init__(self,arr):
        N = len(arr)
        self.arr = arr
        self.current_L = 0
        self.current_R = 0
        self.answer = 0
        self.count = [0]*N
        self.count[arr[0]]+=1
        self.block = N**0.5

    def tcmp(self, sec_1, sec_2):
        if sec_1[0]//self.block!=sec_2[0]/self.block:
            return sec_1[0]//self.block<sec_2[0]/self.block
        else:
            return sec_1[1]<sec_2[1]

    def add(self, index):
        self.count[self.arr[index]]+=1
        if self.count[self.arr[index]]==3:
            self.answer+=1
    def remove(self, index):
        self.count[self.arr[index]]-=1
        if self.count[self.arr[index]]==2:
            self.answer-=1

    def demo1(self,LR_list):
        LR_list = sorted(LR_list, key=functools.cmp_to_key(self.tcmp))

        for (L, R) in LR_list:
            while self.current_L<L:
                self.remove(self.current_L)
                self.current_L+=1
            while current_L>L:
                self.current_L-=1
                self.add(self.current_L)
            while self.current_R>R:
                self.remove(self.current_R)
                self.current_R-=1
            while self.current_R<R:
                self.current_R+=1
                self.add(self.current_R)
                print(self.current_R,  self.count)
```

### 线段树

将[1,n]分解成若干特定的子区间(数量不超过4*n)

用线段树对“编号连续”的一些点，进行修改或者统计操作，修改和统计的复杂度都是O(log2(n))

用线段树统计的东西，必须符合区间加法，（也就是说，如果已知左右两子树的全部信息，比如要能够推出父节点）；否则，不可能通过分成的子区间来得到[L,R]的统计结果。

一个问题，只要能化成对一些“连续点”的修改和统计问题，基本就可以用线段树来解决了

区间求和，求最大，求最小

arr[1,2,...n]，开辟4*n空间的数组

参考链接：https://www.cnblogs.com/jason2003/p/9676729.html
https://www.cnblogs.com/iris001999/articles/9058603.html
https://www.cnblogs.com/xenny/p/9801703.html
https://www.cnblogs.com/AC-King/p/7789013.html

```python
# 备注：树的节点从1开始计数
# arr也是从1开始计数
class Node():
    def __init__(self):
        # 左右区间和区间和
        self.l = None
        self.r = None
        self.sum = None
        self.lz = 0
class solution():
    def __init__(self, arr):
        self.arr = arr
        self.tree = [Node() for _ in range(4*len(self.arr))]
        self.build(1,1,n)
    
    def push_up(self, i):
        # 节点更新
        self.tree[i].sum = self.tree[2*i].sum+self.tree[2*i+1].sum
    def build(self, i, l, r):
        # 建树
        # 节点i对应的区间l，r
        self.tree[i].l = l
        self.tree[i].r = r
        if l==r:
            self.tree[i].sum=self.arr[l]
            return
        mid = (l+r)//2
        self.build(2*i, l, mid)
        self.build(2*i+1, mid+1, r)
        self.push_up(i)
    # 对于单点修改，区间查询，不需要push_down
    def search(self, i, l, r):
        # 区间查询(单点修改)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            return self.tree[i].sum
        if self.tree[i].r<l or r<self.tree[i].l:
            return 0
        s = 0
        if l<=self.tree[2*i].r:
            s = s+self.search(2*i, l, r)
        if self.tree[2*i+1].l<=r:
            s = s+self.search(2*i+1, l, r)
        return s
    def add(self, i, dis, k):
        # 单点修改， self.arr[dis]+=k
        if self.tree[i].l==self.tree[i].r:
            self.tree[i].sum+=k
            return
        if dis<=self.tree[2*i].r:
            self.add(2*i, dis, k)
        else:
            self.add(2*i+1, dis, k)
        self.push_up(i)
    
    # 对于区间修改，区间查询，需要push_down
    def add3(self, i, l, r, k):
        # 第i个节点，区间修改, self.arr[l, r]+=k
        if l<=self.tree[i].l and self.tree[i].r<=r:
            self.tree[i].sum+=k*(self.tree[i].r-self.tree[i].l+1)
            self.tree[i].lz+=k # 表示本区间的Sum正确，子区间的Sum仍需要根据lz的值来调整  
            return
        self.push_down(i)
        # 此时i的区间和lr肯定有交集，可以假设子区间的l或者r无穷
        if self.tree[2*i].r>=l:
            self.add3(2*i, l, r, k)
        if self.tree[2*i+1].l<=r:
            self.add3(2*i+1, l, r, k)
        self.push_up(i)
        return
    
    def push_down(self, i):
        # 下推标记
        if self.tree[i].lz==0:
            return
        self.tree[2*i].lz+=self.tree[i].lz
        self.tree[2*i].sum+=(self.tree[2*i].r-self.tree[2*i].l)*self.tree[i].lz

        self.tree[2*i+1].lz+=self.tree[i].lz
        self.tree[2*i+1].sum+=(self.tree[2*i+1].r-self.tree[2*i+1].l)*self.tree[i].lz

        self.tree[i].lz=0
    
    def search3(self, i, l, r):
        # 区间查询(区间修改)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            return self.tree[i].sum
        self.push_down(i) #  需要下推标记
        res = 0
        if l<=self.tree[2*i].r:
            res+=self.search3(2*i, l, r)
        if self.tree[2*i+1].l<=r:
            res+=self.search3(2*i+1, l, r)
        return res
```

试用题目：

区间染色
区间第k大
矩阵面积并
codevs 1080 （单点修改+区间查询）
codevs 1081 （区间修改+单点查询）
codevs 1082 （区间修改+区间查询）
codevs 3981 （区间最大子段和）
Bzoj 3813　  （区间内某个值是否出现过）
Luogu P2894 （区间连续一段空的长度）
codevs 2000 （区间最长上升子序列）
codevs 3044 （矩阵面积求并）
Hdu 1698 （区间染色+单次统计）
Poj 2777 （区间染色+批量统计）
Hdu 4419 （多色矩形面积并）
Poj 2761 （区间第K大）
Hdu 2305 （最值维护）

### 矩阵面积求并+线段树

参考链接
http://hzwer.com/879.html
https://blog.csdn.net/acmdream/article/details/73301963
https://blog.csdn.net/scutzyz126/article/details/77725438

备注：当有四个横坐标时，线段树的存储实际是：

```bash
# 线段树
        [1,3]
       /     \
      [1,2]   [3,3]
    /     \       
    [1,1]  [2,2]  
每个区间段[l, r] 表示第r+1个横坐标到第r个横坐标之间的线段(有权)的长度
这是因为需要满足区间和。假设[l,r]表示l到r之间的距离，l,m,r：sum[l, r] = hash[r]-hash[l]=sum[l,m]+sum[m+1, r]=hash[r]-hash[m+1]+hash[m]-hash[l]，缺少了m到m+1之间的距离。所以 [l,r]表示l到r+1之间的距离 sum[l, r] = hash[r+1]-hash[l]=sum[l,m]+sum[m+1, r]=hash[r+1]-hash[m+1]+hash[m+1]-hash[l]

# 实际表示的区间
        [1,4]
       /     \
      [1,3]   [3,4]
    /     \       
    [1,2]  [2,3]  
```

```python

class Node():
    def __init__(self):
        # 离散化的横坐标的左右区间l,r：实际表示长度 l-->r+1
        # 线段权重 col (入边加1，出边减1)
        # 当前有效线段的长度sum
        self.l = None
        self.r = None
        self.col = 0
        self.sum = 0

class data():
    def __init__(self, x1=0, x2=0, y=0, flag=0):
        # 横线段的两个横坐标，一个纵坐标，一个标示位表示是入边还是出边
        self.x1 = x1
        self.x2 = x2
        self.y = y
        self.flag = flag

class solution():
    def __init__(self, arr):
        # arr: list: x1, y1, x2, y2
        self.n = len(arr)
        self.tree = [Node() for _ in range(4*self.n)]
        self.a = [data() for _ in range(4*self.n)]
        self.hash = [0 for _ in range(4*self.n)]
        
        self.pre(arr)
        self.build(i, l, r)
        res = self.main()
        print(res)
    
    def push_up(self, i):
        if self.tree[i].col:
            self.tree[i].sum = self.hash[self.tree[i].x2+1]-self.hash[self.tree[i].x1]
        elif self.tree[i].l == self.tree[i].r:
            self.tree[i].sum = 0
        else:
            self.tree[i].sum = self.tree[i*2].sum+self.tree[i*2+1].sum

    def build(self, i, l, r):
        # 初始化线段树
        self.tree[i].l = l
        self.tree[i].r = r
        if l==r:
            self.tree[i].sum=0
            return
        mid = (l+r)//2
        self.build(i*2, l, mid)
        self.build(i*2+1, mid+1, r)
        self.push_up(i) # 当前节点更新
        
    def get_index(self, x):
        # 在self.hash中找到横坐标x对应的离散化坐标
        left, right = 1, 2*self.n
        while left<=right:
            mid = (left+right)//2
            if self.hash[mid]==x:
                return mid
            elif self.hash[mid]>x:
                right = mid-1
            else:
                left = mid+1
        return 0

    def Update(self, left, right, flag, i):
        # 区间修改 [left, right]+=flag，线段树中的节点i
        if left<=self.tree[i].l and self.tree[i].r<=right:
            self.tree[i].col+=flag
            self.push_up(i)
        m = (self.tree[i].l+self.tree[i].r)//2
        if left<m:
            self.Update(left, right, flag, i*2)
        if m<right:
            self.Update(left, right, flag, i*2+1)
        self.push_up(i)


    def pre(self, arr):
        for i, x1, y1, x2, y2 in enumerate(arr):
            self.a[2*i+1] = data(x1, x2, y1, 1)
            self.a[2*i+2] = data(x1, x2, y2, -1)
            self.hash[2*i+1] = x1
            self.hash[2*i+2] = x2
        sort(self.a, key = lambda tmp:tmp.y)
        sort(self.hash)
    
    def main(self):
        res = 0
        self.bulid(i, l, r)
        for i in range(1, 2*self.n):
            # 找到当前线段的横坐标对应的离散化坐标
            left = get_index(self.a[i].x1)
            right = get_index(self.a[i].x2)
            if left<=right:
                self.Update(left, right-1, self.a[i].flag, 1) # 输入线段树时，实际的右端点的离散化坐标要减1
                res += self.tree[1].sum*(self.a[i+1].y-self.a[i].y)
        return res

            


```

### 根据x，求y，使得x*y=11...11

基本原理：tmp=num1*num3，需要tmp的末尾为1，并且非末尾的数字用于下一次进位

例如：
17*3   =  5  1
17*8+5 = 14  1
17*1+14=  3  1

```python
     17
    183
________
     51
   136
   17

```

```python
class Solution():
    def __init__(self):
        self.res = list()
        self.res2 = set()
    def reset(self):
        self.res = list()
        self.res2 = set()
    def demo(self, num1):
        self.reset()
        self.demo1(num1,0)
    def num_pre_last(self, num):
        return num//10, num%10

    def demo1(self, num1, num2):
        if num2 in self.res2:
            print('FFF')
            return
        self.res2.add(num2)

        for num3 in range(0, 10):
            tmp = num1*num3+num2
            pre_tmp, last_tmp = self.num_pre_last(tmp)
            if last_tmp==1:
                # print(num1, num2, num3, tmp, pre_tmp, last_tmp)
                self.res.append(str(num3))
                if pre_tmp==0:
                    print('ttt')
                    print(int(''.join(reversed(self.res))))
                else:
                    self.demo1(num1, pre_tmp)
                self.res.pop()
```

### 蛇形数组

```python
class Solution():
    def __init__(self):
        pass
    
    def demo2(self, x, k):
        y = k-x
        self.Mat[x][y]=self.index
        self.index+=1
    
    def demo1(self, n):
        self.n = n
        self.Mat = [[0 for _ in range(n)] for _ in range(n)]
        self.index = 1
        
        for k in range(n):
        # x: 0--k
            if k%2==0:
                for x in range(k, -1,-1):
                    self.demo2(x, k)
            else:
                for x in range(0, k+1):
                    self.demo2(x, k)
        for k in range(n, 2*n-1):
        # x: k+1-n--n-1
            if k%2==0:
                for x in range(n-1, k-n, -1):
                    self.demo2(x, k)
            else:
                for x in range(k+1-n, n):
                    self.demo2(x, k)
        for i in range(n):
            print(self.Mat[i])

[1, 2, 6]
[3, 5, 7]
[4, 8, 9]
[1,  2,  6,   7]
[3,  5,  8,  13]
[4,  9,  12, 14]
[10, 11, 15, 16]
```

### 石子游戏

https://www.cnblogs.com/Khada-Jhin/p/9609561.html

#### 游戏1

一堆石子n，每次取 1到m 个，甲先取，必胜策略

必胜：n%(m+1)!=0
必败：n%(m+1)=0

#### 游戏2

一堆石子n，围成一个圈，每次只能取连续的一个或者两个，甲先取

n==1|n==2 甲必胜

否则乙取对面的一或者两个石子，使剩下的石子对称，就可以必胜

#### 游戏3

两堆石子分别有(m,n)（n>=m）个，A和B轮流取，A先取。每次可以从一堆中取走任意数量的石子（至少取一个），或者从两堆中取出相同数量的石子，先取完者获胜。A与B都足够聪明，问A是否能获胜。

先手必败: (a[n], b[n])n=0,1,2...
$a[n]=int(\frac{\sqrt{5}+1}{2}*n), b[n]=a[n]+n$
$int ((b[n]-a[n])*\frac{\sqrt{5}+1}{2})==a[n]$

威佐夫博弈
https://baike.baidu.com/item/%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88/19858256?fr=aladdin
https://blog.csdn.net/wu_tongtong/article/details/79295069

#### 游戏4

有n堆石子，每堆石子都有任意个，A和B轮流从取任意堆里取一定的石子，每次只能从一堆里至少取一个，A先取，先取完者胜，问谁胜？

https://blog.csdn.net/shuangde800/article/details/7443566

必胜态：S: S2, S1, S0
必败态：T: T2, T0
T: A[1]^ A[2]^ ... ^ A[n]=0
S: A[1]^ A[2]^ ... ^ A[n]!=0
S2->T2->S2->T2->   ……   ->T2->S1->T0->S0->T0->……->S0->T0(全0)

#### 游戏5

有n堆石子，每堆石子都有任意个，A和B轮流从取任意堆里取一定的石子，每次只能从一堆里至少取一个，A先取，先取完者败，问谁胜？

https://blog.csdn.net/shuangde800/article/details/7443566

必胜态： S2,S1,T0
必败态： T2, S0
S2->T2->S2->T2->   ……   ->T2->S1->S0->T0->S0->……->S0->T0(全0)

所以，游戏4和游戏5 始终把T2态让给对方，抢夺S1是制胜的关键！

#### 游戏6

有t堆石子，每堆石子都有n个，A和B轮流从取任意堆里取一定的石子，每次只能从一堆里至少取一个最多取m个，A先取，先取完者胜，问谁胜？(0<=m,n<=2^31)）

a[i]=n[i]%(m[i]+1)
必胜态：S
必败态：T
S: a[1]^ a[2]^ ... ^ a[n]!=0
T: a[1]^ a[2]^ ... ^ a[n]=0

#### 游戏7

有一堆石子，A和B轮流从中取一定的石子，但规定：第一次不能取完，至少一个；从第二次开始，每个人取的石子数至少为1,至多为对手刚取的石子数的两倍。A先取，问A是否会胜？

https://blog.csdn.net/dgq8211/article/details/7602807

必胜态：非斐波那契数
必败态：斐波那契数列

1,2,3,5,8,13...

#### 游戏8

偶数堆石子排成一行 arr[i,j] ，每堆都有正整数颗石子，游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

动态规划:
记 dp[i,j] 为 arr[i,...,j] 先手相比后手多出来的得分
dp[i,j] = max(arr[i]-dp[i+1,j], arr[j]-dp[i,j-1])

### 给数字n，依次打印1～10^n-1 (全排列）

使用哨兵位

```python
def demo1(n):
    arr = [0 for _ in range(n+1)]
    index = 4
    flag = 0
    while index>0:
        print(arr)
        flag = (arr[-1]+1)//10
        arr[-1] = (arr[-1]+1)%10
        index = n
        while flag:
            index-=1
            flag, arr[index] = (arr[index]+flag)//10, (arr[index]+flag)%10
```

### 特征方程求通项公式

https://blog.csdn.net/ftx456789/article/details/77581458

### 时间复杂度

$$T(n)=aT(n/b)+n^d$$
$n^{\log_b a}, d < \log_b a$
$n^d \log n, d=\log_b a$
$n^d, d > \log_b a$

### 最大堆

维护最大堆的性质：左右子树已经为最大堆，从上到下维护堆的性质，根节点逐级下降

```python
def MAX-HEAPIFY(A, i):
    l = left(i)
    r = right(i)
    largest = i
    if l<=A.heap-size and A[l]>A[i]:
        largest = l
    if r<=A.heap-size and A[r]>A[i]:
        largest = r
    if largest!=i:
        swap(i, largest)
        MAX-HEAPIFY(A, largest)
```

建堆：从下到上遍历，对每个节点维护堆的性质 O(n)

```python
def BUILD-HEAP(A):
    A.heap-size = len(A)
    for i in range(len(A)//2, -1, -1):
        MAX-HEAPIFY(A, i)
```

堆排序：从下到上遍历

```python
def HEAPSORT(A):
    BUILD-HEAP(A):
    for i in range(len(A), 0, -1):
        swap(A[1], A[i])
        A.heap-size-=1
        MAX-HEAPIFY(A, 1)
```

堆元素增加优先级(破坏父节点的性质): 从下到上

```python
def HEAP-INCREASE-KEY(A, i, key):
    if key<A[i]:
        print('error')
    A[i]=key
    while i>0 and A[parrent[i]]<A[i]:
        swap(A[i], A[parrent[i]])
        i = parrent[i]
```

堆插入新的元素：破坏父节点

```python
def MAX-HEAP-INSERT(A, key):
    A.heap-size = A.heap-size+1
    A[A.heap-size]=-INF
    HEAP-INCREASE-KEY(A, A.heap-size, key)
```

最大堆弹出堆顶

```python
def HEAP-EXTRACT-MAX(A):
    if A.heap-size<1:
        print("error")
    res = A[1]
    A[1]=A[A.heap-size]
    A.heap-size=A.heap-size-1
    MAX-HEAPIFY(A, 1)
```

### 树中的最长路径(叶结点到叶结点)

https://blog.csdn.net/liuyi1207164339/article/details/50898902

或者说，对于root，最远距离=
a. 经过root：左右子树深度+2
b. 不经过root，左子树的最长路径或者右子树的最长路径

或者说，对每个root，求得经过该root的最长距离(左右子树深度+2)，然后求全局最大即可

```python
class solution():
    def __init__(self):
        self.max_path = 0 # 保留全局最大
    def HeightOfBinaryTree(self, root):
        if not root:
            return 0
        height_of_left = self.HeightOfBinaryTree(root.left)
        height_of_right = self.HeightOfBinaryTree(root.right)
        root_max_path = height_of_left+height_of_right+2
        self.max_path = max(self.max_path, root_max_path)
        return max(height_of_left, height_of_right)+1

```

### 100层楼2个鸡蛋，如何得知鸡蛋能承受几层的撞击

https://blog.csdn.net/weixin_34419321/article/details/92339658

https://www.cnblogs.com/yangai/p/5391533.html

$$f[n][m] = \min_k(\max(f[n-1][k-1], f[n][m-k])+1), k=1,...,m$$

$x+(x-1)+(x-2)+...+1=\frac{x(x+1)}{2}<=100, x=14$

### 乘法矩阵

leetcode 668

### 项目的最大收益

1. 在可以做的情况下，找利润最大的项目
2. 项目资金每一次变动，都可以加入一些新的项目

动态排序：堆

大根堆：小于等于项目资金的项目，利润率排序
小根堆：大于项目资金的项目，项目资金排序
堆只存储项目编号

### python 堆 heap

```python
import heapq
nums = [2, 3, 5, 1, 54, 23, 132]
heapq.heapify(nums)
heapq.heappush(nums, 45)
heapq.heappop(nums)
heapq.heapreplace(nums, 66)
```

优先队列，自定义优先级

```python
import heapq

# 使用heapq实现优先队列
#定义一个可比较对象
class CompareAble:
    def __init__(self,priority,jobname):
        self.priority = priority
        self.jobname = jobname
    # python3 不支持 cmp 操作
    # def __cmp__(self, other):
    #     if self.priority < other.priority:
    #         return -1
    #     elif self.priority == other.priority:
    #         return 0
    #     else:
    #         return 1

    def __lt__(self, other):
        if self.priority <= other.priority:
            return True
        else:
            return False

joblist = []

heapq.heappush(joblist,CompareAble(80,'eat'))
heapq.heappush(joblist,CompareAble(70,'a write plan2'))
heapq.heappush(joblist,CompareAble(70,'write plan'))
heapq.heappush(joblist,CompareAble(90,'sleep'))
heapq.heappush(joblist,CompareAble(100,'write code'))

while joblist:
    task = heapq.heappop(joblist)
    print(task.priority,task.jobname)
# 数值越小，排序越靠前
(70, 'write plan')
(70, 'a write plan2')
(80, 'eat')
(90, 'sleep')
(100, 'write code')
```

### 分金条的最小花费

第一种，动态规划：

f(i,j) = min(f(i,k)+f(k+1,j))+sum(i,j), k = i+1,...,j-1

看着很眼熟

第二种，最优二叉树计算带权路径长度

每个数字计算的次数等于它的高度

```python
import heapq

def demo1(n, arr):
    heapq.heapify(arr)
    res = 0
    while len(arr)>1:
        combine = heapq.heappop(arr)+heapq.heappop(arr)
        res+=combine
        heapq.heappush(arr, combine)
    return res
```



### 加油站良好出发点问题

参考链接：https://blog.csdn.net/ShellDawn/article/details/90546915

这个博主写的很好，下面简单阐述原理

好加油站：从该加油站出发，遍历求和 arr[i]=oil[i]-dist[i] 总是大于等于0

点可以分为四种：待好点(arr[i]>=0)，坏点(arr[i]<0)，变好点(由待好点变成的，arr[i]>=0 and 任意的j都有 sum(i,j)>=0)，变坏点(由待好点变成的，arr[i]>=0 and 存在j有 sum(i,j)<0)

如何利用已经确定的待好点(变好点或者变坏点)来减少下一个待好点的确定。

不妨假设待好点的排列 i2(待好点), i1(已确定的待好点)，且i2,i1之间没有其他待好点。

1.**i1是变好点**

i1, i1+1, ..., n-1, 0, ..., i1-1
遍历求和总是大于等于0

1.1.**i2是变好点**

结论：i2, ..., i1-1 遍历求和大于等于0 等价于 i2 是变好点。
i2, i2+1,..., i1-1, i1, ..., n-1, 0, ..., i2-1
显然有 i1, ..., i2-1 遍历求和大于等于0
所以只需要证明 i2, ..., i1-1 遍历求和大于等于0，就可以证明i2是变好点。
反之，如果i2是变好点，那么 i2, ..., i1-1 遍历求和也大于等于0.
所以 i2, ..., i1-1 遍历求和大于等于0 等价于 i2 是变好点。

1.2 **i2是变坏点**

结论：i2,...i1-1存在j求和小于0等价于i2 是变坏点
i2, i2+1,..., i1-1, i1, ..., n-1, 0, ..., i2-1
下面证明使i2是变坏点的加油站j一定在 i2, i2+1,..., i1-1中间
反证法：如果j不在i2, i2+1,..., i1-1中，那么j在i1, ..., n-1, 0, ..., i2-1中，那么i2, i2+1,..., i1-1 遍历求和大于等于0，又i1是好点，i1...j遍历求和也大于等于0，则 i2,....,j遍历求和应该也是大于等于0，与i2是变坏的加油站j满足i2,...,j求和小于0矛盾。
反之，如果在 i2,...,i1-1中存在j，使i2,...,j求和小于0，那么显然i2是变坏点。
所以 i2,...i1-1存在j求和小于0等价于i2 是变坏点

2.**i1是变坏点**

i1,...,j1,...,i1-1
i1,...,j1-1的遍历求和总是大于等于0, 并且i1,...,j1的求和小于0，显然j1是坏点，而不是待好点

2.1.**i2是变好点**

i2,...,i1,...i2-1

2.1.1 **i2,...j1,...,i1,...,i2-1**

结论：i2,...,i1遍历求和大于等于0等价于i2是变好点
如果i2,...,i1遍历求和总是大于等于0，又i1,...,i2,..j1-1遍历求和总是大于等于0，且j1大于i2，那么i2是变好点。
反之，如果i2是变好点，那么i2,...,i1遍历求和大于等于0。
所以i2,...,i1遍历求和大于等于0等价于i2是变好点
此时重复计算了i2,...,j1之间的遍历求和

2.1.2 **i2,...,i1,...j1,...,i2-1**

结论：i2,...,i1和i2,...,j1,...,i2-1遍历求和都大于等于0 等价于 i2是变好点
如果i2,...,i1遍历求和大于等于0，又i1,...,j1-1遍历求和大于等于0，则可以跳过i1,...,j1-1的计算，直接跳到j1，从j1,...,i2-1开始遍历求和，都大于等于0，则i2是变好点。
反之，如果i2是变好点，那么i2,...,i1和i2,...,j1,...,i2-1遍历求和都大于等于0
所以 i2,...,i1和i2,...,j1,...,i2-1遍历求和都大于等于0 等价于 i2是变好点

2.2 **i2是变坏点**

2.2.1 **i2,...j1,...,i1,...,i2-1**

结论：i2,...i1-1存在j2求和小于0等价于i2 是变坏点
反证法：如果j2不在i2,...,i1-1中，那么i2,...,i1-1遍历求和大于等于0，由2.1.1可以得出i2是变好点，矛盾。
此时重复计算了i2,...,j1之间的遍历和

2.2.2 **i2,...,i1,...j1,...,i2-1**

结论：i2,...i1-1或者j1,...i2-1存在j2求和小于0等价于i2 是变坏点
反证法：如果j2不在i2,...i1-1或者j1,...i2-1中，由2.1.2可以得出i2是变好点，矛盾

**算法**：根据以上引理，可以得出以下算法：
从n-1,n-2,...,0遍历 待好点i,
arr[i]: 第0位：值， 第1位：表示点的情况，待好点-1, 坏点0, 变好点1, 变坏点2， 第2位：表示变坏点的变坏情况j，第3位：表示变坏点的变坏情况sum_ij

循环体：j：i,...,i-1
sum_ij+=arr[j]

i 是好点：
sum_ij>=0

1. arr[j+1][1]==1 ,1.1
2. arr[j+1][1]==2 and i<=arr[j+1][2]<=j ,2.1.1
3. j+1==i ,绕了一圈，第一个变好点

i是坏点：
sum_ij<0
arr[i][1] = 2
arr[i][2] = j
arr[i][3] = sum_ij

i不确定:
if arr[j+1][1]==2: ,2.1.2, 2.2.2
    sum_ij+=arr[j+1][3]
    j=arr[j+1][2]
j = (j+1)%n

**算法复杂度证明**：
第一个变好点的复杂度是 N
1.1, 1.2, 2.2.1, 2.2.2 遍历时都不会对上一个已经确定的待好点遍历过的数字二次遍历，这四种情况下 复杂度是 N
2.1.1, 2.2.2 遍历时会对少量已经遍历过的数字二次遍历，但是观察可以得出这些二次遍历的数字总是小于等于i2,...,i1的差距，所以二次遍历的数字个数累加和总是小于等于 N，复杂度是 2N

所以总的时间复杂度是O(N), 空间复杂度是O(1)

```python
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        
        n = len(gas)
        arr = []
        for i in range(n):
            val = gas[i]-cost[i]
            if val<0:
                arr.append([val, 0, 0, 0])
            else:
                arr.append([val, -1, 0, 0])
        res = self.can2(arr)
        return res
        
    def can2(self, arr):
        # arr[i]: 0: 数字, 1: 点类型, 2: j, 3: sum_ij
        n = len(arr)
        for i in range(n-1, -1, -1):
            if arr[i][1]==0:
                continue
            
            j, sum_ij = i, arr[i][0]
            
            while True:
                if sum_ij<0:
                    arr[i] = [arr[i][0], 2, j, sum_ij]
                    break
                elif arr[(j+1)%n][1]==1 or (arr[(j+1)%n][1]==2 and i<=arr[(j+1)%n][2]<=j) or ((j+1)%n==i):
                    arr[i] = [arr[i][0], 1, n, 0]
                    break
                else:
                    if arr[(j+1)%n][1]==2:
                        sum_ij, j = sum_ij+arr[(j+1)%n][3], arr[(j+1)%n][2]
                    else:
                        j = (j+1)%n
                        sum_ij += arr[j][0]
                        
        res = -1
        for i, (val, h, j, sum_ij) in enumerate(arr):
            if h==1:
                res = i
                break
        return res
                    
```

### 幂次

pow(a,n) = pow(a, n//2)* pow(a, n//2)*a, n=2k+1
pow(a,n) = pow(a, n//2)* pow(a, n//2), n=2k

```python
# 递归
def pow(a, n):
    if n==1:
        return a
    tmp = pow(a, n//2)
    if n%2==1:
        return tmp*tmp*a
    else:
        return tmp*tmp

# 循环
def pow(a, n):
    res = 1
    while n:
        if n&1:
            res = res*a
        a = a*a
        n = n<<1
    return res
```

### 员工上班期望总时间最长

链接：https://www.nowcoder.com/questionTerminal/09a48370f5f74faab22ab7fb684ae5d8?orderByHotValue=0&pos=41&mutiTagIds=601
来源：牛客网

某大公司有这么一个规定：只要有一个员工过生日，当天所有员工全部放假一天。但在其余时候，所有员工都没有假期，必须正常上班。这个公司需要雇用多少员工，才能让公司一年内所有员工的总工作时间期望值最大？

一个人，对于任意一天，过生日的概率是 1 / 365, 不过生日的概率是 364 / 365
n个人，对于任意一天，没任何人过生日的概率是(364 / 365)^n
n个人，对于任意一天，有人过生日的概率是 1 - (364 / 365)^n
那么365天里有人过生日的期望天数是 365（1 - (364 / 365)^n）天，
则n个人，365天，每个人工作的期望天数是365 - 365（1 - (364 / 365)^n） = 365(364 / 365)^n
从而所有人的期望工作天数的和为：365n(364 / 365)^n，求导数，导数不小于0，递增。

### 组合 路径方法数

二维矩阵从左上角到右下角的路径方法数。简单的dp，让优化，用排列组合的方式优化

走到(m,n)位置需要m+n步,从中选择n步向右走,就是组合数C(m+n) n

### 大数相减

```python
#include <stdio.h>
#include <string.h>
 
int x[100]={0},y[100]={0},z[100]={0};
int main()
{
    char a[100],b[100];//定义两个字符数组来接收两个大数；
    int i,j,m,n,q;
    scanf("%s %s",a,b);
    m=strlen(a);
    n=strlen(b);
    j=0;
    for(i=m-1;i>=0;i--)//字符数组转化为倒序int型数组；
    {
        x[j]=a[i]-'0';
        j++;
    }
    j=0;
    for(i=n-1;i>=0;i--)
    {
        y[j]=b[i]-'0';
        j++;
    }
    if(m>n)//判断减数与被减数的位数
    {
        sub(x,y,m);
    }
    else if(m<n)
    {
        printf("-");
        sub(y,x,n);
    }
    else
    {
        for(i=m-1;i>=0;i--)
        {
            if(x[i]!=y[i])
            {
                if(x[i]>y[i])
                {
                    sub(x,y,m);
                    break;
                }
                else
                {
                    printf("-");
                    sub(y,x,m);
                    break;
                }
            }
            else
            {
                printf("0");
                printf("\n");
                break;
            }
        }
    }
    return 0;
}
void sub(int x[],int y[],int p)
{
    int i,o;
    for(i=0;i<p;i++)//进行相减
    {
        if(x[i]>=y[i])
        {
            z[i]=x[i]-y[i];
        }
        else
        {
            z[i]=x[i]-y[i]+10;
            x[i+1]--;
        }
    }
    for(i=p-1;i>=0;i--)//排除前几位为零的情况
    {
        if(z[i]!=0)
        {
            o=i;
            break;
        }
    }
    for(i=o;i>=0;i--)//倒序打出结果
    {
        printf("%d",z[i]);
    }
    printf("\n");

————————————————
https://blog.csdn.net/qq_41040871/article/details/80073072
```



### 买卖股票收益最大问题

https://www.jianshu.com/p/9fa0faff99da

T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])

初始化：T[-1][k][0]=0, T[-1][k][1]=-sys.maxsize

```python
import sys

class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if not prices:
            return 0
        if k>=n/2:
            Tik0, Tik1 = 0, -sys.maxsize
            for i in range(n):
                Tik0_old = Tik0
                Tik0 = max(Tik0, Tik1+prices[i])
                Tik1 = max(Tik1, Tik0_old-prices[i])
            return Tik0
        Ti0 = [0 for _ in range(k+1)]
        Ti1 = [-sys.maxsize  for _ in range(k+1)]
        for i in range(n):
            for j in range(k, 0, -1):
                Ti0[j] = max(Ti0[j], Ti1[j]+prices[i])
                Ti1[j] = max(Ti1[j], Ti0[j-1]-prices[i])
        return Ti0[-1]
```

### ZOJ 3329 One Person Game

有三个骰子，分别有k1,k2,k3个面。每次掷骰子，如果三个面分别为a,b,c则分数置0，否则加上三个骰子的分数之和。当分数大于n时结束。求游戏的期望步数。初始分数为0。

p[k]: 表示三个骰子分数之和等于k的概率
E[i]: 表示当前分数是i，游戏结束的期望步数。当i>n时，E[i]=0

所以有，对当前分数i，投出分数k={3, ..., k1+k2+k3}或者0后，还需要平均走的步数的等式关系
$$E[i] = \sum_k (p[k]*E[i+k])+p[0] *E[0]+1$$
很明显，E[i]是关于E[0]的线性方程，不妨设
$$E[i]=A[i]*E[0]+B[i]$$
代入上式有：
$$E[i]=(\sum_k(p[k]* A[i+k])+p[0])* E[0]+(\sum_k(p[k]*B[i+k])+1)$$
所以有
$$A[i]=\sum_k(p[k]* A[i+k])+p[0], i<=n$$
$$B[i]=\sum_k(p[k]* B[i+k])+1, i<=n$$
$i>n, A[i]=B[i]=0$
所以，可以依次求得 A[n], B[n],..., A[0], B[0]
$$E[0]=B[i]/(1-A[i])$$

### I/O 复用

针对多个 I/O 流，有两种方式：

方式1：对每个 I/O 流，建立一个进程，当某个 I/O 流准备好之后，对应的进程启动传输。这样的方式的问题是进程大部分时间都是休息状态
方式2(I/O复用): 用一个进程当做管理员，管理所有的 I/O 流，如果某个 I/O 流准备好，就唤醒管理员，管理员处理对应的 I/O 流

I/O 复用的方法：select、poll、epoll

参考链接：
https://www.iteye.com/blog/uule-2432063
https://blog.csdn.net/xd_rbt_/article/details/80287959

### 判断点是否在三角形内部

参考：
https://www.cnblogs.com/TenosDoIt/p/4024413.html
https://www.cnblogs.com/graphics/archive/2010/08/05/1793393.html

推荐第二种或者第三种

A(x1,y1), B(x2, y2), C(x3,y3), P(x,y)

第二种：
P与C同侧，且P与A同侧，且P与B同侧，以P与C同侧为例
方向可以用叉积表示：ABxAP = (x2-x1)*(y-y1)-(y2-y1) *(x-x1)
ABxAC = (x2-x1)*(y-y1)-(y2-y1) *(x-x1)
同向：(ABxAP)*(ABxAC)>=0

第三种：
重心法
$$AP=u* AB+v* AC, 0< u < 1, 0< v <1, 0< u+v <1 $$

### 最大的leftMax与rightMax之差的绝对值

参考：
https://www.jianshu.com/p/a028d69d7dd6
https://blog.csdn.net/zuochao_2013/article/details/79814127

全局的最大值肯定会出现在左部分或者右部分，如果在左部分，那么右部分的最大值一定大于等于最后一个元素，直接将右部分切到只剩一个元素即可，如果在右部分，那么左部分的最大值一定大于等于第一个元素，直接将左部分切到只剩一个元素即可

```python
def demo1(arr):
    max_val = arr[0]
    for val in arr:
        max_val = max(max_val, val)
    res = max_val-min(arr[0], arr[-1])
    return res

if __name__=='__main__':
    n = int(input())
    arr = list(map(int, input().split()))
    res = demo1(arr)
    print(res)
```

## 保留/删除最后一个1

删除最后一个1: n&(n-1)
只保留最后一个1: n&(~n+1)

## 指数

```python
def demo1(a,n):
    res = 1
    while n:
        if n&1:
            res = res*a
        a = a*a
        n = n>>1
```

## 从1到n整数中1出现的次数

https://www.cnblogs.com/xuanxufeng/p/6854105.html

## 判断扑克牌是否是顺子

没有对子并且max-min<=5

https://blog.csdn.net/qq_37859539/article/details/86327221

```python
def demo1(numbers):
    max_v = max(numbers)
    min_v = min(numbers)
    flag = 0
    for i in range(len(numbers)):
        if numbers[i]==0:
            continue
        if(flag&(1<<numbers[i])!=0):
            return False
        flag = flag|(1<<numbers[i])
    return max_v-min_v<=4
```

## 不用加减乘除做加法

和：a^b
进位：(a&b)<<1

```python
def demo1(a, b):
    sum, carry=0, 0
    while b:
        sum = a^b
        carry = (a&b)<<1
        a, b = sum, carry
    return a
```

## 区间合并

对于当前区间i，如果能与前面的区间合并，则将合并后的区间记为当前区间，如果不能合并，则将前面的区间记录到结果中。

```python
class Interval():
    def __init__(self, s=0, e=0):
        self.start = s
        self.end = e

def merge(intervals):
    n = len(intervals)
    if n<2:
        return intervals
    res = list()
    for i in range(1, n):
        last = intervals[i-1]
        now = intervals[i]
        if now.start<=last.end:
            now.end = max(now.end, last.end)
            now.start = last.start
        else:
            res.append(last)
    res.append(intervals[-1])
```

## 找出没有出现过的数字

1-n中，有些数字出现了多次，有些数字没有出现，全部找出来

```python
def f(arrs):
    n = len(arrs)
    for i in range(n):
        index = abs(arrs[i])
        if arrs[index]>0:
            arrs[index] = - arrs[index]
    res = list()
    for i in range(n):
        if arrs[i]>0:
            res.append(i+1)
    return res
            
```

#### 旋转数组找特定值

```python
# 旋转数组，先判断mid在哪里
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        l, r = 0, len(nums)-1
        while l<=r:
            mid = (l+r)//2
            if nums[mid]==target:
                return mid
            if nums[mid]<=nums[r]:
                if nums[mid]<target<=nums[r]:
                    l = mid+1
                else:
                    r = mid-1
            else:
                if nums[l]<=target<nums[mid]:
                    r = mid-1
                else:
                    l = mid+1
        return -1
```

#### 旋转数组找最小值

```python
def findMin(nums):
    left = 0
    right = len(nums)-1
    mid = 0
    res = 0
    while left<=right:
        mid = (left+right)//2
        if nums[mid]<mid[right]:
            right = mid-1
            res = mid
        elif nums[mid]==mid[right]:
            right = right-1
        else:
            left = mid+1
    return res
```

#### 数组有正有负，求数组中任意三个数乘积的最大值

最大值只可能是来自 最小的两个数乘最大的数 或者 最大的三个数字相乘

```python
array = sorted(array, reverse=True)
res = max(array[0]*array[1]*array[2], array[0]*array[-1]*array[-2])
```

#### 合并排序

```python
def merge_sort(arrs, l, r):
    # [l, r] 进行排序
    if r-l<=0:
        return
    mid = (l+r)//2
    merge_sort(arrs, l, mid)
    merge_sort(arrs, mid+1, r)
    merge(arrs, l, mid, r)

def merge(arrs, l, mid, r):
    help = list()
    p, q = l, mid+1
    while p<=mid or q<=r: # 只要有一部分不为空
        
        if (q>r) or (p<=mid and arrs[p]<=arrs[q]): # 右半部分没有值或者左半部分的值较小
            # print(1, p, q, l, mid, r)
            help.append(arrs[p])
            p = p+1
        else:
            # print(2, p, q, l, mid, r)
            help.append(arrs[q])
            q = q+1
    arrs[l:r+1] = help[:]

n = len(arrs)
merge_sort(arrs, 0, n-1) #
```

#### 快速排序

```python
def quick_sort(arrs, l, r):
    # 递归实现
    if r-l<=1:
        return
    k = partion(arrs, l, r)
    quick_sort(arrs, l, k-1)
    quick_sort(arrs, k+1, r)

def partion(arrs, l, r):
    
    base = arrs[r]
    i, j = l-1, l # l~i：小于base的数字,i+1~j：大于base的数字
    for j in range(l, r+1):
        if arrs[j]<=base:
            i = i+1
            arrs[i], arrs[j] = arrs[j], arrs[i]
    return i

def quick_sort(arrs):
    # 非递归实现
    # 用栈保存区间
    stack = [(0, len(arrs)-1)]
    while stack:
        left, right = stack.pop()
        if right-left<=1:
            continue
        index = partion(arrs, left, right)
        stack.append(left, index-1)
        stack.append(index+1, right)
```

#### 稳定排序和不稳定排序

稳定排序：冒泡排序、归并排序
不稳定排序：快速排序

发生远距离交换时，容易导致不稳定

### DFS 广度优先搜索用队列，深度优先搜索用栈

```python
# 广度优先搜索就是层次遍历
import collections
def BFS(root):
    queue = collections.deque()
    queue.append(root)
    res = list()
    while queue:
        node = queue.popleft()
        if node:
            res.append(node.val)
            queue.append(node.left)
            queue.append(node.right)


# DFS包括前序遍历、中序遍历、后序遍历
def DFS(root):
    # 递归
    if not root:
        return None
    print(root.val)
    DFS(root.left)
    DFS(root.right)

def DFS(root):
    # 迭代
    if not root:
        return None
    stack = list()
    stack.append(root)
    while stack:
        node = stack.pop()
        if node:
            print(node.val)
            stack.append(node.right)
            stack.append(node.left)
  
```

### 平衡二叉树

https://www.cnblogs.com/zhangbaochong/p/5164994.html

对α的左儿子的左子树进行一次插入:单旋
对α的左儿子的右子树进行一次插入：双旋：左儿子左旋，根节点右旋

### 最小生成树的prim算法

Prim算法：每次加入最短权重的顶点

```python
# 假设节点从1开始计数，共n个节点
class solution():
    def __init__(self):
        self.n = n # 节点个数
        self.edge # 邻接矩阵，不相邻的顶点间距离记为None
        self.d # list 每个节点到生成树的距离
        self.vis # list 节点是否在生成树中
        self.p # list 每个节点的父节点
    
    def prim(self,):
        # 以1为根节点，初始化 self.d self.p
        for i in range(self.n+1):
            self.d[i] = self.edge[1][i]
            if self.edge[1][i]:
                self.p[i] = 1
        self.vis[1] = True

        # 
        while True:
            # 从非最小生成树的顶点集合中选出最短距离的顶点
            min_dis, ver = 1e9, -1
            for i in range(self.n+1):
                if (not self.vis[i]) and (self.d[i]<min_dis):
                    min_dis, ver = self.d[i], i
            if ver==-1:
                break # 最小生成树
## 没写完呢 https://blog.csdn.net/qq_41410799/article/details/81836927
            

        





```

#### 背包问题

https://blog.csdn.net/weixin_41162823/article/details/87878853

#### 重复数字

现在有一些你n+1个数字（0 < x < n），这些数字中有且仅有一个数字重复了，不仅仅重复一次

第一种方法：将数字i放在对应的位置i上
第二种方法：快排 我们把从1~n的数字从中间的数字m分为两部分，前面一半为1~m，后面一半为m+1~n。如果1~m的数字的数目等于m，则不能直接判断这一半区间是否包含重复的数字，反之，如果大于m，那么这一半的区间一定包含重复的数字；如果小于m，另一半m+1~n的区间里一定包含重复的数字。接下来，我们可以继续把包含重复的数字的区间一分为二，直到找到一个重复的数字。

#### 64匹马，8个赛道，找出跑得最快的4匹马

https://blog.csdn.net/u013829973/article/details/80787928

8 + 1 + 1 + 1 = 11 场

#### 《剑指offer》面试题14：剪绳子

给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n>1并且m>1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0] * k[1]*…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。

https://blog.csdn.net/slionls/article/details/93200175

####  在一个给定的n个点的平面，找到在某条直线上的最多的点的数量。

https://segmentfault.com/a/1190000005678407
https://www.cnblogs.com/grandyang/p/4579693.html

对每一个点，计算与其他点的斜率(dx,dy)，保存在哈希表中，斜率相同则在同一条直线上。

#### 5亿个数找中位数

https://zhuanlan.zhihu.com/p/112306835

双堆法：大顶堆，小顶堆 O(N*log(N/2))

分治法：顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。

排序：快排(随机选择算法)

先分页排序，再多路归并排序

#### 求k个数组包含每个数组至少一个元素的最小范围（待字闺中，备忘）

https://blog.csdn.net/wdxin1322/article/details/12970913

归并排序

#### happy number

一个数是不是快乐是这么定义的：对于一个正整数，每一次将该数替换为他每个位置上的数字的平方和，然后重复这个过程直到这个数变为1，或是无限循环但始终变不到1。如果可以变为1，那么这个数就是快乐数。

显然证明：快乐数不会出现趋近无限大的情况：https://leetcode-cn.com/problems/happy-number/solution/kuai-le-shu-by-leetcode-solution/

4->16->37->58->89->145->42->20->4

方法一：利用集合或者哈希表判断是否循环

方法二：利用快慢指针判断是否循环

```python
class Solution:
    # 方法一：利用hash表或者集合存储出现过的数字
    def isHappy(self, n: int) -> bool:
        hashset = set()
        hashset.add(n)
        res = True
        while n!=1:
            n = self.squareSum(n)
            if n in hashset:
                res = False
                break
            hashset.add(n)
        return res
    
    # 方法二：利用快慢指针判断是否有环 Floyd's cycle-finding algorithm
    def isHappy(self, n: int) -> bool:
        fast, slow = n, n
        res = True
        while slow!=fast:
            slow = self.squareSum(slow)
            fast = self.squareSum(self.squareSum(fast))
        if fast!=1:
            res = False
        return res

    # 方法三：利用happy number的性质：循环一定会出现4，非循环最后一定是1
    
    def isHappy(self, n: int) -> bool:
        while n not in [1,4]:
            n = self.squareSum(n)
        return res==1

    def squareSum(self, n):
        n_sum = 0
        while n:
            n_sum = n_sum+(n%10)*(n%10)
            n = n//10
        return n_sum

    def get_next(n):
            res = 0
            while n>0:
                n, digit = divmod(n, 10)
                res = res+digit**2
            return res

```

#### 最大子序列和

https://blog.csdn.net/bryansun/article/details/104225829

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res=min(nums)
        dp = 0
        for val in nums:
            dp = max(dp, 0)+val
            res = max(res, dp)
        return res
```

#### Group Anagrams

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]



```python
# 这里没有采用直接hash：key：val形式，而是在hash中记录key所对应res中的行数，直接将结果记录在res中
# 方法一
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        key_nums = dict()
        res = list()
        for val in strs:
            key = tuple(sorted(val))
            if key not in key_nums:
                key_nums[key] = len(res)
                res.append([])
            res[key_nums[key]].append(val)
        return res

# 方法一的简洁版
def groupAnagrams(self, strs):
    d = {}
    for w in sorted(strs):
        key = tuple(sorted(w))
        d[key] = d.get(key, []) + [w]
    return d.values()

# 方法二：计数排序
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        key_nums = dict()
        res = list()
        for val in strs:
            key = self.getkey(val)
            if key not in key_nums:
                key_nums[key] = len(res)
                res.append([])
            res[key_nums[key]].append(val)
        return res
    
    def getkey(self, s):
        key_nums = [0]*26
        for val in s:
            key_nums[ord(val)-ord('a')]+=1
        res = ''
        for i, val in enumerate(key_nums):
            res+=chr(ord('a')+i)*val
        return res
```

#### Counting Elements

Given an integer array arr, count element x such that x + 1 is also in arr.

```python
# 方法一：先放到hash表中，然后通过key排序的hash表前后key之间的距离判断，而不用每次判断x+1在hash表中
class Solution:
    def countElements(self, arr: List[int]) -> int:
        m = dict()
        for val in arr:
            m[val] = m.get(val, 0)+1 
        sorted(m)
        p_key = -2
        res = 0
        for k, v in m.items():
            if k-p_key==1:
                res+=m[p_key]
            p_key = k
        return res


# 方法二：用长1000的list记录每个数字出现的次数，判断x+1处的位置是否大于0
class Solution:
    def countElements(self, arr: List[int]) -> int:
        cnt = [0]*1002
        res = 0
        for val in arr:
            cnt[val]+=1
        for val in arr:
            if cnt[val+1]>0:
                res+=1
        return res

```

#### Backspace String Compare

Input: S = "ab#c", T = "ad#c"
Output: true
Explanation: Both S and T become "ac".

从后向前遍历，遍历方向和#的控制方向一致

i<0, j<0: True
i>0, j<0: False
i<0, j>0: False
i>0, j>0: S[i]==T[j]

==>

i<0 or j<0: i==j
i>0, j>0: S[i]==T[j]


```c++
# https://www.cnblogs.com/grandyang/p/10447783.html
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        int i = (int)S.size() - 1, j = (int)T.size() - 1, cnt1 = 0, cnt2 = 0;
        while (i >= 0 || j >= 0) {
            while (i >= 0 && (S[i] == '#' || cnt1 > 0)) S[i--] == '#' ? ++cnt1 : --cnt1;
            while (j >= 0 && (T[j] == '#' || cnt2 > 0)) T[j--] == '#' ? ++cnt2 : --cnt2;
            if (i < 0 || j < 0) return i == j;
            if (S[i--] != T[j--]) return false;
        }
        return i == j;
    }
};
```

```python
class Solution:
    def backspaceCompare(self, S: str, T: str) -> bool:
        i1, i2 = len(S)-1, len(T)-1
        cnt1, cnt2 = 0, 0
        res = True
        while i1>=0 or i2>=0:
            while i1>=0 and (cnt1>0 or S[i1]=='#'):
                if S[i1]=='#':
                    cnt1+=1
                    i1-=1
                elif cnt1>0:
                    cnt1-=1
                    i1-=1
            while i2>=0 and (cnt2>0 or T[i2]=='#'):
                if T[i2]=='#':
                    cnt2+=1
                    i2-=1
                elif cnt2>0:
                    cnt2-=1
                    i2-=1
            if i1<0 or i2<0:
                res = i1==i2
                break
            if S[i1]!=T[i2]:
                res = False
                break
            i1-=1
            i2-=1
        res = i1==i2
        return res
```

#### Last Stone Weight

We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x <= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)

1 <= stones.length <= 30
1 <= stones[i] <= 1000

有两种思路：

思路1：用优先级队列，时间复杂度 O(nlgn) 空间 O(n)，n表示长度
思路2：计数排序，时间复杂度 O(n**2) 空间 O(n)  n 表示最大值

```python
# 思路一：优先级队列
# 这里插入0的复杂度是O(1)，所以不需要判断是否为0
import heapq
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        q = [-val for val in stones]
        heapq.heapify(q)
        while len(q)>1:
            heapq.heappush(q, heapq.heappop(q)-heapq.heappop(q))
        return -q[0]
```

```python
# 思路二：计数排序
# 这里slow和fast之间的数字次数全部为0，只可能是slow-fast出现在slow和fast之间，所以slow可以直接跳到max(fast, slow-fast)
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        bucket = [0]*10001
        for val in stones:
            bucket[val]+=1
        
        slow, fast = 10000, 10000
        while slow>0:
            if bucket[slow]%2==0:
                slow-=1
                continue
            
            fast = min(slow-1, fast)
            while fast>0 and bucket[fast]==0:
                fast-=1
            if fast==0:
                break
            
            bucket[fast]-=1
            bucket[slow-fast]+=1
            slow = max(slow-fast, fast)
            
        return slow
```



