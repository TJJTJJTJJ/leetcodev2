# leetcode

## Contiguous Array

标签：连续子数组

思路一：累加和+hash

求连续子数组的0、1个数相等，可以转换为-1(遇0减1，遇1加1)、1的累加和为0的最长连续子数组。
累加和ans，以 {和：位置} 的hash表形式记录。对于满足条件的连续子数组(i,...,j)，一定有ans[j]-ans[i]==0，等价于 长度=j-hash[ ans[ j]]。特殊的，初始化{0:-1}（如果从0开始到某个位置j符合条件，那么需要满足长度=j-hash[0]）

```python
# 思路一：累加和，问题求连续子数组的0、1个数相等，可以转换为-1(遇0减1，遇1加1)、1的累加和为0的最长连续子数组。
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        m = {0:-1}
        ans, res = 0, 0
        for i, val in enumerate(nums):
            val = val*2-1
            ans = val+ans
            if ans in m:
                res = max(res, i-m[ans])
            else:
                m[ans] = i            
        return res

```

扩展：数组中只有 0，1，2，找最长的连续子数组，使0、1、2出现的个数相等？？？？？？？？？

## 连续子数组和最大

标签：连续子数组

思路：动态规划
f(i)以i为结尾的连续子数组的最大和
f(i) = max(arr[i]+f(i-1), arr[i])
res = max(f(i),...)

```python
# 思路一：动态规划
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        res, ans = 0, 0
        for val in nums:
            ans = max(ans, 0)+val
            res = max(res, ans)
        return res

```

## 连续子数组异或和为0的最多划分

标签：连续子数组
思路：累异或和+hash

map: 0~i的异或:i
或者说记录 异或数字的最新位置
dp:
dp[k-1]+1, if k-i的异或为0==>0-i的异或出现过
dp[i-1]， if k-i的异或不为0

或者说map记录异或的数字，对于第i个位置的异或，需要找到上一个相同数字的位置

```python
def demo1(n, arr):
    dict_or2i = {0:0}
    arr2 = [0 for _ in range(n)]
    Xor = 0
    for i in range(n):
        Xor = Xor^arr[i]
        if Xor in dict_or2i:
            arr2[i] = arr2[dict_or2i[Xor]]+1
        if i>0:
            arr2[i] = max(arr2[i-1], arr2[i])
        dict_or2i[Xor] = i
    # print(arr2)
    return arr2[-1]
```

## 数组中的连续子数组和为k

标签：连续子数组

思路：累加和+hash

Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        sum_dict = {0:1}
        tmp = 0
        res = 0
        for i, val in enumerate(nums):
            tmp+=val
            if tmp-k in sum_dict:
                res+=sum_dict[tmp-k]
            sum_dict[tmp]=sum_dict.get(tmp, 0)+1
        return res
```

## 非排序数组中和小于等于k的最长子序列
？？？
1. 用 h[i]=max(sum, h[i-1]) 记录0-i的累加和的最大值
2. h[i] 表示以i为头的和最小的连续子序列
h[i]=min(h[i+1]+arr[i], arr[i])
map[i]=map[i+1], i


## 验证括号字符串 678

https://www.cnblogs.com/grandyang/p/7617017.html

### ()

思路1：栈
思路2：用变量cnt，左括号加1，右括号减1，如果出现负数，返回false，最终cnt应该为0

### ()*

思路1：左括号栈和星号栈：右括号优先匹配左括号栈，匹配右括号结束后，左括号栈和星号栈匹配，如果星号栈顶大于左括号栈顶(*，可以匹配，反之不能匹配 *()

```python
class Solution {
public:
    bool checkValidString(string s) {
        stack<int> left, star;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '*') star.push(i);
            else if (s[i] == '(') left.push(i);
            else {
                if (left.empty() && star.empty()) return false;
                if (!left.empty()) left.pop();
                else star.pop();
            }
        }
        while (!left.empty() && !star.empty()) {
            if (left.top() > star.top()) return false;
            left.pop(); star.pop();
        }
        return left.empty();
    }
};
```

思路2：正反遍历：正遍历将星号当左括号，左括号+1，右括号-1，遍历过程中res应该总是大于等于0，最后结果res，如果res=0，返回true，如果res>0，左括号或者星号比较多，如果res<0，返回false，逆遍历将星号当右括号，右括号+1，左括号-1，如果res=0，返回true，如果res>0，也返回true，res<0，返回false。

如果正遍历res>0，则 (+*>)
如果反遍历res>0，则 (<)+*
所以 -* <(-)< *，所以 |(-)|< *，只需要把|(-)|个 * 变成相应的括号即可

```python
class Solution {
public:
    bool checkValidString(string s) {
        int left = 0, right = 0, n = s.size();
        for (int i = 0; i < n; ++i) {
            if (s[i] == '(' || s[i] == '*') ++left;
            else --left;
            if (left < 0) return false;
        }
        if (left == 0) return true;
        for (int i = n - 1; i >= 0; --i) {
            if (s[i] == ')' || s[i] == '*') ++right;
            else --right;
            if (right < 0) return false;
        }
        return true;
    }
};
```

思路三：

https://leetcode.com/problems/valid-parenthesis-string/discuss/107577/Short-Java-O(n)-time-O(1)-space-one-pass

The idea is to similar to validate a string only contains '(' and ')'. But extend it to tracking the lower and upper bound of valid '(' counts. My thinking process is as following.

scan from left to right, and record counts of unpaired ‘(’ for all possible cases. For ‘(’ and ‘)’, it is straightforward, just increment and decrement all counts, respectively.
When the character is '*', there are three cases, ‘(’, empty, or ‘)’, we can think those three cases as three branches in the ongoing route.
Take “(**())” as an example. There are 6 chars:
----At step 0: only one count = 1.
----At step 1: the route will be diverted into three branches.
so there are three counts: 1 - 1, 1, 1 + 1 which is 0, 1, 2, for ‘)’, empty and ‘(’ respectively.
----At step 2 each route is diverged into three routes again. so there will be 9 possible routes now.
-- For count = 0, it will be diverted into 0 – 1, 0, 0 + 1, which is -1, 0, 1, but when the count is -1, that means there are more ‘)’s than ‘(’s, and we need to stop early at that route, since it is invalid. we end with 0, 1.
-- For count = 1, it will be diverted into 1 – 1, 1, 1 + 1, which is 0, 1, 2
-- For count = 2, it will be diverted into 2 – 1, 2, 2 + 1, which is 1, 2, 3
To summarize step 2, we end up with counts of 0,1,2,3
----At step 3, increment all counts --> 1,2,3,4
----At step 4, decrement all counts --> 0,1,2,3
----At step 5, decrement all counts --> -1, 0,1,2, the route with count -1 is invalid, so stop early at that route. Now we have 0,1,2.
In the very end, we find that there is a route that can reach count == 0. Which means all ‘(’ and ‘)’ are cancelled. So, the original String is valid.
Another finding is counts of unpaired ‘(’ for all valid routes are consecutive integers. So we only need to keep a lower and upper bound of that consecutive integers to save space.
One case doesn’t show up in the example is: if the upper bound is negative, that means all routes have more ‘)’ than ‘(’ --> all routes are invalid --> stop and return false.

Hope this explanation helps.

```python
    public boolean checkValidString(String s) {
        int low = 0;
        int high = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                low++;
                high++;
            } else if (s.charAt(i) == ')') {
                if (low > 0) {
                    low--;
                }
                high--;
            } else {
                if (low > 0) {
                    low--;
                }
                high++;
            }
            if (high < 0) {
                return false;
            }
        }
        return low == 0;
    }
```


## Leftmost Column with at Least a One

判断1的最左边列

Imagine there is a pointer p(x, y) starting from top right corner. p can only move left or down. If the value at p is 0, move down. If the value at p is 1, move left. Try to figure out the correctness and time complexity of this algorithm.

或者可以理解成，对于上一行的最优解，可以减少下一行的判断

动态规划

```python
# """
# This is BinaryMatrix's API interface.
# You should not implement it, or speculate about its implementation
# """
#class BinaryMatrix(object):
#    def get(self, x: int, y: int) -> int:
#    def dimensions(self) -> list[]:

class Solution:
    def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:
        n, m = binaryMatrix.dimensions()
        i, j = 0, m
        while i<n:
            if j==0:
                break
            elif binaryMatrix.get(i, j-1)==1:
                j = j-1
            else:
                i = i+1
        res = j
        if j==m:
            res = -1
        return res
```

## Bitwise AND of Numbers Range

```python
# 思路一
class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -> int:
        i = 0
        while m!=n:
            m, n = m>>1, n>>1
            i+=1
        res = m<<i
        return res

# 思路二：
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        while (m < n) n &= (n - 1);
        return n;
    }
};
```

## LRU算法

```python
class Node:
    def __init__(self, key=-1, value=-1):
        self.key = key
        self.value = value
        self.pre = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.CurrentSize = 0
        self.capacity = capacity
        self.map = dict()
        self.first = Node()
        self.last = Node()
        self.first.next, self.last.pre = self.last, self.first

    def get(self, key: int) -> int:
        res = -1
        if key in self.map:
            res = self.map[key].value
            self.moveToFirst(key)
        return res

    def put(self, key: int, value: int) -> None:
        if key in self.map:
            self.map[key].value = value
            self.moveToFirst(key)
        else:
            node = Node(key, value)
            self.map[key] = node
            self.CurrentSize+=1
            if self.CurrentSize>self.capacity:
                self.deleteLast()
            self.insertToFirst(node)
            
        
    def moveToFirst(self, key):
        node = self.map[key]
        node.pre.next, node.next.pre = node.next, node.pre
        self.insertToFirst(node)
    
    def insertToFirst(self, node):
        self.first.next.pre, node.next = node, self.first.next
        self.first.next, node.pre = node, self.first
    
    def deleteLast(self,):
        del self.map[self.last.pre.key]
        self.last.pre.pre.next, self.last.pre = self.last, self.last.pre.pre
        


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

## 55 Jump Game

[2,3,1,1,4]
reach[i]: 表示位置0出发可以到达i的前提下，位置0出发可以到达的最远距离
reach 表示位置0出发可以到达的最远距离
i:0,-->1,2, reach:2, 从0出发，最远可以到位置2
i:1,-->2,3,4, reach:4，从0出发，最远可以到位置4
i:2,-->3, reach:4
定义f(n)表示从0出发，到达的最远位置，
f(n-1)与f(n)的关系：f(n) = max(f(n-1), n+arrs[n]),if n<=f(n-1)

```python
class Solution:

    def canJump(self, nums: List[int]) -> bool:
        reach = nums[0]
        for i, val in enumerate(nums):
            if i>reach:
                return False
            elif reach>=len(nums)-1:
                return True
            reach = max(reach, i+val)
        return True
```

## Maximal Square

tag: 最大正方形

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if (not matrix) or (not matrix[0]):
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[int(matrix[i][j]) for j in range(n)] for i in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if i>0 and j>0 and dp[i][j]==1:
                    dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j])+1
                res = max(res, dp[i][j])    
        return res*res
```

## First Unique Number

tag：第一次出现一次的数

```python
class FirstUnique:

    def __init__(self, nums: List[int]):
        self.List = nums[:]
        self.Map = dict()
        for val in self.List:
            self.Map[val] = self.Map.get(val, 0)+1
        self.p = 0

    def showFirstUnique(self) -> int:
        while self.p<len(self.List) and self.Map[self.List[self.p]]>1:
            self.p+=1
        if self.p<len(self.List):
            return self.List[self.p]
        else:
            return -1

    def add(self, value: int) -> None:
        self.List.append(value)
        self.Map[value] = self.Map.get(value, 0)+1
```

## Binary Tree Maximum Path Sum

```python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.res = -10**9
        self.maxPathSum2(root)
        return self.res
    
    def maxPathSum2(self, root):
        if not root:
            return 0
        left = self.maxPathSum2(root.left)
        right = self.maxPathSum2(root.right)
        cur = max(0, left)+max(0, right)+root.val
        self.res = max(self.res, cur)
        cur = max(left, right, 0) + root.val
        return cur
```

## Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isValidSequence(self, root: TreeNode, arr: List[int]) -> bool:
        self.arr = arr
        res = self.isValidSequence2(root, 0)
        return res
        
    def isValidSequence2(self, root, k):
        if k==len(self.arr) and (not root):
            return True
        
        if root and k<len(self.arr) and root.val==self.arr[k]:
            if k==len(self.arr)-1:
                return self.isValidSequence2(root.left, k+1) and self.isValidSequence2(root.right, k+1)
            else:
                return self.isValidSequence2(root.left, k+1) or self.isValidSequence2(root.right, k+1)
        else:
            return False
        return None

# 解法2

def isValidSequence(root, arr):
    n = len(arr)
    def dfs(i, node):
        if not node or i == n or arr[i] != node.val:
            return False
        if i == n - 1 and not (node.left or node.right):
            return True
        return dfs(i+1, node.left) or dfs(i+1, node.right)
    return dfs(0, root)
```

## 逆波兰表示法(Reverse Polish Notation)

参考链接：

https://blog.csdn.net/shyjhyp11/article/details/71375153

### 计算方法：

如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。

### 中缀表达式转换成波兰表达式和逆波兰表达式

一、 将中缀表达式转换成后缀表达式算法：
　　1、从左至右扫描一中缀表达式。
　　2、若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈
　　3、若读取的是运算符
　　　　(1) 该运算符为左括号"("，则直接存入运算符堆栈。
　　　　(2) 该运算符为右括号")"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号为止。
　　　　(3) 该运算符为非括号运算符：
　　　　　　(a) 若运算符堆栈栈顶的运算符为括号（只可能是左括号），则直接存入运算符堆栈。
　　　　　　(b) 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。
　　　　　　(c) 若比运算符堆栈栈顶的运算符优先级低或相等，则不断输出栈顶运算符到操作数堆栈，直到栈顶没有运算符的优先级大于或者等于当前预算符（即栈顶存在运算符的话，优先级一定是小于当前运算符），最后将当前运算符压入运算符堆栈。
　　4、当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。

二、逆波兰表达式求值算法：
　　1、从左到右依次扫描语法单元的项目。
　　2、如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目。
　　3、如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算。
　　4、如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算。
　　5、将运算结果重新压入堆栈。
　　6、重复步骤2-5，堆栈中即为结果值。

一、 将中缀表达式转换成前缀表达式算法：
　　1、首先设定一个操作符栈，从右到左顺序扫描整个中缀表达式，如果是操作数，则直接归入前缀表达式；
　　2、如果是操作符，则检测器是否是右括号，如果是右括号，则直接将其入栈；
　　3、如果是左括号，则将栈中的操作符依次弹栈，归入前缀表达式，直至遇到右括号，将右括号弹栈，处理结束；
　　4、如果是其他操作符，则检测栈顶操作符的优先级与当前操作符的优先级关系，
　　5、如果栈顶操作符优先级大于当前操作符的优先级，则弹栈，并归入前缀表达式，直至栈顶操作符优先级小于等于当前操作符优先级，这时将当前操作符压栈。
　　6、当扫描完毕整个中缀表达式后，检测操作符栈是否为空，如果不为空，则依次将栈中操作符弹栈，归入前缀表达式。最后，将前缀表达式翻转，得到中缀表达式对应的前缀表达式。

二、波兰表达式求值算法：
　　1、从右到左依次扫描语法单元的项目。
　　2、如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目。
　　3、如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算。
　　4、如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算。
　　5、将运算结果重新压入堆栈。
　　6、重复步骤2-5，堆栈中即为结果值。

https://www.cnblogs.com/journal-of-xjx/p/5940030.html

## single-number-ii

现在有一个整数类型的数组，数组中只有一个元素只出现一次，其余元素都出现三次。你需要找出只出现一次的元素

```python
class Solution:
    # solution one
    # def singleNumber(self, nums):
    #     bit = [0] * 32
    #     for num in nums:
    #         for i in range(32):
    #             bit[i] += num >> i & 1
    #     res = 0
    #     for i, val in enumerate(bit):
    #         # if the single numble is negative,
    #         # this case should be considered separately 
    #         if i == 31 and val%3:
    #             res = -((1<<31)-res)
    #         else:
    #             res |= (val%3)*(1<<i)
    #     return res

    # solution two
    # def singleNumber(self, nums):
    #     a, b, z = 0, 0, 0
    #     for val in nums:
    #         a, b = a^(b&val), b^val
    #         c = a&b
    #         a, b = a&~c, b&~c
    #     return b

    def singleNumber(self, nums):
        K = 3
        # O(NlogK)
        # K, 2^(N-1)<K<=2^(N)
        z = list(map(int, list(bin(K))[2:]))# 长度是N， 碰到z产生进位，即归零
        N = len(z)
        a = [0 for _ in range(N)]
        c = [0 for _ in range(N)]
        for val in nums:
            # print(val)
            for i in range(N-1):
                a[i] = a[i]^(a[i+1]&val)
            a[-1] = a[-1]^val

            # print('a', a)

            d = -0b1
            for i in range(N):
                if z[i]:
                    d = d&a[i]
                else:
                    d = d&(~a[i])
            a = list(map(lambda x: x&~d, a))
        res = a[-1]

        return res

# 卡诺图
class Solution {
public:
    int singleNumber(int A[], int n) {
        if (n == 0) return 0;
        int a = 0;
        int b = 0;
        int c;
        int ta, tb;
        for (int i = 0; i < n; i++) {
            c = A[i];
            ta = a;
            tb = b;
            a = (~c & ta & ~tb) | (c & ~ta & tb);
            b = (~c & ~ta & tb) | (c & ~ta & ~tb);
        }
        return b;
    }
};
```

https://leetcode-cn.com/problems/single-number-ii/comments/

## 179. Largest Number

ab> ba-->a>>b (a“大于”b)

第一步：证明传递性：
ab> ba, bc> cb,-->ac>ca

设$[ b]$表示b的位数，有：
$a*10^{[ b]}+b>b *10^{[ a]}+a -->a *(10^{[b]}-1)>b *(10^{[a]}-1)-->a/(10^{[a]}-1)>b/(10^{[b]}-1)$ 
同理有：
$b/(10^{[b]}-1)>c/(10^{[c]}-1)$
所以有：
$a/(10^{[a]}-1)>c/(10^{[c]}-1)-->ac>ca$

第二步：证明这种组合是最大

根据第一步的传递性，有n个数字的“大小”排列是唯一的

下面用数学归纳法证明这种大小排列的组合是最大的

当n=2时，ab>ba，a>>b，ab的组合是最大的
假设当n-1个数字时，这种组合也是最大的，
大小排列为{a_1, a_2, ..., a_{n-1}}
组合数为a_1 a_2 ... a_{n-1}
证明n个数字时，这种组合是最大的，
大小排列为{a_1, a_2, ..., a_{n}}
组合有n种情况：分别以a_1开头，a_2开头...a_n开头
根据n-1个数字的假设，有：
以a_1开头的组合数最大为a_1 a_2 ... a_n
以a_2开头的组合数最大为a_2 a_1 ... a_n
...
以a_n开头的组合数最大为a_n a_1 ... a_{n-1}

接下来证明这n个数中，a_1 a_2 ... a_n最大
因为在前两个数字{a_1, a_2}中，根据假设有a_1 a_2>a_2 a_1，所以a_1 a_2 ... a_n>a_2 a_1 ... a_n
在前三个数字{a_1, a_2, a_3}中，根据假设有 a_1 a_2 a_3 的排列最大，所以 a_1 a_2 a_3 ... a_n > a_3 a_1 a_2 ... a_n
...
在前n-1个数字中，有 a_1 a_2 a_3 ... a_n > a_{n-1} a_1 a_2 ... a_n
对于a_n a_1 ... a_{n-1}，将a_n向后挪，a_n a_1 ... a_{n-1}< a_1 a_n ... a_{n-1}< a_1 a_1 a_n ... a_{n-1}<...< a_1 a_2 ... a_n，得证。证明n个数字时，这种组合是最大的。

```python
# 解法一
import functools

class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        nums = list(map(str, nums))

        def compare(a, b):
            if a+b>b+a:
                return -1
            else:
                return 1
        
        nums = sorted(nums, key=functools.cmp_to_key(compare))
        res = "".join(nums)
        if res[0]=='0':
            res = '0'
        return res
    
# 解法二
class Solution:
    def largestNumber(self, nums: List[int]) -> str:
        def val2(val):
            val2str = str(val)
            return val/(10**len(val2str)-1)
        nums2 = list(map(val2, nums))
        nums = sorted(zip(nums,nums2), key=lambda x:x[1], reverse=True )
        nums = [x[0] for x in nums]
        res = ''.join(map(str, nums))
        if res[0]=='0':
            res = '0'
        return res  
```

## 185. Department Top Three Salaries

选出前三，包含重复数据

```python
select e1.Name as 'Employee', e1.Salary
from Employee e1
where 3>
(
    select count(distinct e2.Salary)
    from Employee e2
    where e2.Salary>e1.Salary
)
;
# 方法1
select d.Name as Department, e1.Name as Employee, e1.Salary as Salary
from Department d, Employee e1
where d.Id=e1.DepartmentId
and 3>
(
    select count(distinct e2.salary)
    from Employee e2
    where e2.salary>e1.salary
    and e1.DepartmentId=e2.DepartmentId
)
;
# 方法2
SELECT
    d.Name AS 'Department', e1.Name AS 'Employee', e1.Salary
FROM
    Employee e1
        JOIN
    Department d ON e1.DepartmentId = d.Id
WHERE
    3 > (SELECT
            COUNT(DISTINCT e2.Salary)
        FROM
            Employee e2
        WHERE
            e2.Salary > e1.Salary
                AND e1.DepartmentId = e2.DepartmentId
        )
;
```

100, 200, 300, 300, 400
得到：3, 2, 1, 0

## 187. Repeated DNA Sequences

固定长度L的子序列重复问题，核心思想是滑动窗口+hashset。具体有三种方法

https://leetcode-cn.com/problems/repeated-dna-sequences/solution/zhong-fu-de-dnaxu-lie-by-leetcode/

第一种：O(L)时间获取滑动窗口的子序列，不推荐
时间复杂度：O((N-L)L),空间复杂度：O((N-L)L)

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)     
        seen, output = set(), set()

        # iterate over all sequences of length L
        for start in range(n - L + 1):
            tmp = s[start:start + L]
            if tmp in seen:
                output.add(tmp[:])
            seen.add(tmp)
        return output
```

第二种：Rabin-Karp：使用旋转哈希实现常数时间窗口切片：核心是在常数时间内获取滑动窗口的哈希值
时间复杂度：O(N-L),空间复杂度：O(N-L)

以 AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT 为例，首先，将字符串转化为整数数组：A:0, C:1, G:2, T:3，得 00000111110000011111100000222333，此时这串序列可以看成以4为基数的数字
第一个序列可以计算出一个10进制数字：0000011111
$h_0 = \sum_{i=0}^{L-1}c_i*4^{L-1-i}$
第二个切片0000111110由滑动窗口右移所得：
$h_1 = h_0* 4-c_0*4^L+c_{L+1}$
可以发现窗口切片可以在常数时间完成

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)
        if n <= L:
            return []
        
        a = 4
        aL = pow(a, L)

        to_int = {'A':0, 'C':1, 'G':2, 'T':3  }
        nums = [to_int[val] for val in s]
        h, seen, output = 0, set(), set()
        for i in range(L):
            h = h*a + nums[i]
        seen.add(h)
        for start in range(1, N-L+1):
            h = h*a-nums[start-1]*aL+nums[start+L-1]
            if h in seen:
                output.add(s[start:start+L])
            seen.add(h)
        return output
```

第三种：位操作：使用掩码实现常数时间窗口切片
时间复杂度：O(N-L),空间复杂度：O(N-L)
与Rabin-Karp方法类似，只是将基数为4的序列用二进制表示
以 AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT 为例，首先，将字符串转化为整数数组：A: 0: 00, C: 1: 01, G: 2: 10, T: 3: 11
对于第一个序列，计算掩码(左移表示乘法，或表示加法)：
bitmask = (bitmask<<2)|nums[i]
对于第二个序列，可以通过第一个序列的掩码计算：
左移两位空出末尾，去掉高位多出来的1，加上新出现的数字
$bitmask_2 = (bitmask_1<<2) \& ( \sim (3<< L))|nums[i]$
其中 bitmask & (1<< n)表示取第n位
bitmask & ~(1<< n) 表示设置第n位为0，高位和低位不变，因为bitmask高位为0，所以可以理解成减法
加法：ab均为二进制，b为2位数(2进制)，a * 4+b: a<<2|b
减法：a高位为0，减去a的n位：0110->0010，a-b* 2^n:a&~(b<< n)

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        L, n = 10, len(s)
        if n <= L:
            return []
        
        to_int = {'A':0, 'C':1, 'G':2, 'T':3  }
        nums = [to_int[val] for val in s]
        bitmask, seen, output = 0, set(), set()
        for i in range(L):
            bitmask = (bitmask<<2)|nums[i]
        seen.add(bitmask)
        for start in range(1, N-L+1):
            bitmask = bitmask<<2
            bitmask = bitmask|nums[start+L-1]
            bitmask = bitmask&~(3<<2*L)
            if h in seen:
                output.add(s[start:start+L])
            seen.add(bitmask)
        return output
```

## 字符串匹配算法

三种方法:Rabin-Karp、KMP、BM

第一种：Rabin-Karp：滚动哈希
O(n-m)
计算大小为m的窗口内字符串的哈希值：
$H(S, j) = \sum_{i=0}^{m-1}\alpha^{m-(i+1)}*char(s_i)$
O(1)时间计算下一个窗口的哈希值
$H(S, j+1) = H(S, j)*\alpha-\alpha^m * char(s_j)+char(s_{j+m})$

第二种：KMP算法

next：表示最长匹配前缀字符串的长度
https://www.zhihu.com/question/21923021：海纳

PMT到next
O(m+n)

KMP算法：计算以0开头的前缀和以n-1结尾的后缀之间的匹配程度

例如abb，计算前缀{a, ab}和后缀{b, bb}之间的字符串匹配

KMP生成的next数组 next[i]：表示[0...i-1]前缀和后缀的最长匹配字串，不包括 [0...i-1]本身，即[0...next[i]-1]与[i-next[i], ..., i-1] 相同
所以 next:长度是len(p)+1，

```python
# 生成next数组，不包括最后一个字符
def getnext(p):
    n = len(p)
    next = [0]*(n+1)
    next[0] = -1
    i, j = 0, -1 # j不同
    while i<n:
        if j==-1 or p[i]==p[j]:
            i, j = i+1, j+1
            next[i] = j
        else:
            j = next[j]
    return next

def KMP(t, p):
    i, j = 0, 0 # j不同
    while i<len(t) and j<len(p):
        if j==-1 or t[i]==p[j]:
            i, j = i+1, j+1
        else:
            j = next[j]
    if j==len(p):
        return i-j
    else:
        return -1

```

第三种 BM 算法

看着很麻烦，不写了

## 二分法模板

nums: F, F, F, T, T, T

```python
def bis(nums):
    l, r = 0, len(nums)-1
    res = -1
    while l<=r:
        mid = (l+r)//2
        if nums[mid]>target:
            res = mid
            r = mid-1
        else:
            l = mid+1
    return res
            

```

## 最长重复子串

Rabin-Karp：见 187. Repeated DNA Sequences，核心思想是滚动哈希

对不同长度进行RK方法匹配重复子串

```python
# 二分法+Rabin-Karp+防止溢出
class solution:

    def longestDupSubstring(S):
        # 字符串中只有a-z
        to_int = {k:k-'a' for k in S}
        nums = [to_int[k] for k in S]
        n = len(S)
        left, right = 0, n-1
        res_start, res_L = -1, 0
        while left<right:
            mid = (left+right)//2
            mid_start = RK(nums, mid)
            if RK(nums, mid)!=-1:
                left = mid+1
                res_start = mid_start
                res_L = mid
            else:
                right = mid-1
        if res_start:
            res = S[res_start:res_start+res_L]
        else:
            res = -1
        return res


    def RK(nums, L):
        n = len(nums)
        h, a, aL = 0, 26, 1
        seen = dict{}
        mod = pow(2, 32)
        for i in range(L):
            h = (h*a+nums[i])%mod
            aL = (aL*a)%mod
        seen[h]=0
        for start in range(1, n-L+1):
            h = (h-nums[start-1]*aL%mod)%mod
            h = (h*a+nums[start+L-1])%mod
            if h in seen and check(nums, seen[h], start, L):
                return start
        return -1

    def check(nums, start1, start2, L):
        # 取模会造成不一样的字符有相同的哈希值
        for i in range(L):
            if nums[start1+i]!=nums[start2+i]:
                return False
        return True
```

## 192. Word Frequency

```bash
cat words.txt | xargs -n1 | sort | uniq -c | sort -rn | awk '{print $2,$1}'
cat words.txt|tr -s ' ' '\n'|sort |uniq -c|sort -r|awk '{print $2,$1}'
```

```bash
# https://www.cnblogs.com/wangqiguo/p/6464234.html
# xargs: 将输出作为参数输入
~ $ ls | cat                                                                    
test1.txt                                                                       
test2.txt                                                                       
~ $ ls | xargs cat                                                              
1 2 3 4                                                                         
2   
# xargs 将输出分行
cat test1.txt | xargs
1
2
3
4

```

## 193 Valid Phone Numbers    

```bash
grep -P '^(\d{3}-|\(\d{3}\) )\d{3}-\d{4}$' file.txt # -P 才能使用\d，否则只能使用[0-9]
grep -E '(^([0-9]{3})\s|^[0-9]{3}-)[0-9]{3}-[0-9]{4}$'
sed -n -r '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/p' file.txt
awk '/^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$/' file.txt
```

## 194. Transpose File

```bash
# 方法一
awk '
{
    for(i=1;i<=NF;i++){
        if(NR==1){
            res[i]=$i
        }
        else{
            res[i]=res[i]" "$i
        }
    }
}END{
    for(j=1;j<=NF;j++){
        print(res[j])
    }
        
}' file.txt
# 方法二
colu=$(awk '{print NF}' file.txt | uniq)
for((i=1;i<=colu;i++))
do
  cut -d' ' -f$i file.txt|xargs
done
```

## 195. Tenth Line

```bash
awk 'NR==10' file.txt
tail -n+10 file.txt|head -1
sed -n "10p" file.txt
```

## 199. Binary Tree Right Side View

```python
# 广度优先遍历 BFS 队列 每一层的最后一个节点
import queue
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        que, res = queue.Queue(), []
        que.put(root)
        while not que.empty():
            n = que.qsize()
            for i in range(n):
                cur = que.get()
                if cur.left:
                    que.put(cur.left)
                if cur.right:
                    que.put(cur.right)
                
            res.append(cur.val)
        return res

# 深度优先遍历 DFS: 栈 每个深度的第一个节点

import queue
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        stack, res = [(root, 0)], []
        while stack:
            cur, depth = stack.pop()
            if len(res)==depth:
                res.append(cur.val)
            if cur.left:
                stack.append((cur.left, depth+1))
            if cur.right:
                stack.append((cur.right, depth+1))
        return res
```

## 200. 岛屿数量

```python
# dfs O(nm)
import collections
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid or not grid[0]:
            return 0
        res = 0
        n, m = len(grid), len(grid[0])
        dx = [-1, 0, 1, 0]
        dy = [0, -1, 0, 1]
        def dfs(i, j):
            stack = [(i, j)]
            grid[i][j]="0"
            while stack:
                i, j = stack.pop()
                for x, y in zip(dx, dy):
                    ii, jj = i+x, j+y
                    if -1<ii<n and -1<jj<m and grid[ii][jj]=="1":
                        stack.append((ii, jj))
                        grid[ii][jj]="0"
            return
        
        def bfs(i, j):
            que = collections.deque()
            que.append((i, j))
            grid[i][j]="0"
            while que:
                i, j = que.popleft()
                for x, y in zip(dx, dy):
                    ii, jj = i+x, j+y
                    if -1<ii<n and -1<jj<m and grid[ii][jj]=="1":
                        que.append((ii, jj))
                        grid[ii][jj]="0"
            return 


        for i in range(n):
            for j in range(m):
                if grid[i][j]=="1":
                    bfs(i, j)
                    res = res+1
        return res

```

## 并查集

参考链接:
https://www.cnblogs.com/cyjb/p/UnionFindSets.html

并查集有三个基本操作：

1. makeSet(s):建立一个新的并查集，包含s个单元素集合
2. unionSet(x, y):将x和y所在的集合合并
3. find(x):找到元素x所在的集合的代表

ps：我以为会用链表/静态链表表示树，但实际上使用数组就可以表示树的关系

```python
# 基于rank优化和路径压缩优化：O(lg* n)<< O(lg n)， 推荐
class UnionFind:
    def __init__(self, n):
        # 按rank合并, parent 初始化为自身
        self.parent = list(range(n))
        self.rank = [0]*n # 秩来表示树高度的上界 # 基于rank优化
    
    def find(self, x):
        # 递归 路径压缩优化
        if self.parent[x]!=x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
        
    
    def find2(self, x):
        # 非递归版 路径压缩优化
        p = x
        while p!=self.parent[p]:
            p = self.parent[p]
        while x!=p:
            x, self.parent[x] = self.parent[x], p
        return p
    
    def unionSet(self, x, y):
        
        x, y = self.find(x), self.find(y)
        if x==y:
            return
        if self.rank[x]==self.rank[y]:
            self.parent[x] = y
            self.rank[y] = self.rank[y]+1
        elif self.rank[x]>self.rank[y]:
            self.parent[y] = x
        else:
            self.parent[x] = y
        return 
```

```python
# 基于元素个数优化，不推荐
class UnionFind2:
    def __init__(self, s):
        # 按树中元素个数合并，初始化为-1
        # 定义，如果parent是正数，表示其父节点，如果是负数，表示其为树根，且值的绝对值等于树中的元素个数
        n = len(s)
        self.parent = [-1]*n
    
    def find(self, x):
        if self.parent[x] < 0:
            return x
        self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def unionSet(self, x, y):
        x = self.find(x)
        y = self.find(y)
        if x == y:
            return 
        if self.parent[x] < self.parent[y]:
            self.parent[x] = self.parent[x]+self.parent[y]
            self.parent[y] = x
        else:
            self.parent[y] = self.parent[x]+self.parent[y]
            self.parent[x] = y

```

## 岛屿类问题：DFS遍历框架

https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/

```python
def dfs(x, y):
    if not inArea(x, y):
        return 
    
    if grid[x][y]!=1:
        return
    
    grid[x][y]=2
    
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]

    for ddx, ddy in zip(dx, dy):
        dfs(x+ddx, y+ddy)

def inArea(x, y):
    return -1<x<n and -1<y<m
```

### LeetCode 695. Max Area of Island

```python
def dfs(x, y):
    if not inArea(x, y):
        return 0
    
    if grid[x][y]!=1:
        return 0
    
    grid[x][y]=2
    
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    res = 1
    for ddx, ddy in zip(dx, dy):
        res = res + dfs(x+ddx, y+ddy)
    return res

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    res = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                area = dfs(i, j)
                res = max(res, area)
    return res
```

### LeetCode 827. Making A Large Island （Hard）

```python
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]
def dfs(x, y, index):
    if not inArea(x, y):
        return 0
    
    if grid[x][y]!=1:
        return 0
    
    grid[x][y]=index
    
    res = 1
    for ddx, ddy in zip(dx, dy):
        res = res + dfs(x+ddx, y+ddy)
    return res

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    area = {0:0}
    index = 2
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                area[index] = dfs(i, j, index)
                index += 1
    
    res = max(area.values())
    for i in rang(n):
        for j in range(m):
            if grid[i][j]==0:
                seen = {grid[i+ddx][j+ddy] for ddx, ddy in zip(dx, dy)}
                res = max(res, 1+sum(area[index] for index in seen))
    
    return res
```

### LeetCode 463. Island Perimeter

岛屿的边有两种：第一种是跨出区域出现的周长；第二种是进入水区域出现的周长

```python
def dfs(x, y):
    if not inArea(x, y):
        return 1
    
    if gridp[x][y]==0:
        return 1
    
    if grid[x][y]!=1:
        return 0
    
    grid[x][y]=2
    
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    res = 0
    for ddx, ddy in zip(dx, dy):
        res = res + dfs(x+ddx, y+ddy)
    return res

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    res = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                per = dfs(i, j)
                res = max(res, per)
    return res
```

### 200. 岛屿数量

```python
def dfs(x, y):
    if not inArea(x, y):
        return 0
    
    if grid[x][y]!=1:
        return 0
    
    grid[x][y]=2
    
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    for ddx, ddy in zip(dx, dy):
        dfs(x+ddx, y+ddy)
    return 0

def inArea(x, y):
    return -1<x<n and -1<y<m

def main(grid):
    n, m = len(grid), len(grid[0])
    res = 0
    for i in range(n):
        for j in range(m):
            if grid[i][j]==1:
                dfs(i, j)
                res += 1
    return res
```

## 201. 数字范围按位与

解法1：数字n和m的公共前缀[m, n]

证明：m = ...0..., n=...1...，显然有：前面的公共前缀按位与不会发生改变，后缀一定会出现1000，按位与之后全为0

```python
def main(m, n):
    i = 0
    while m!=n:
        m = m>>1
        n = n>>1
        i+=1
    return m<<i
```

解法2：Brian Kernighan:x & (x-1) 去掉最后一个1，可以用于计算数字的二进制表示中1的个数

```python
def main(m, n):
    while m<n:
        n = n&(n-1)
    return n
```

## 207. 课程表

图中有没有环 拓扑排序

解法一：bfs，从入度为0的节点开始

构建入度列表和邻接表

```python
from collections import deque
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        
        indegrees = [0]*numCourses
        adjacency = [[] for _ in range(numCourses)]

        for cur, pre in prerequisites:
            indegrees[cur] += 1
            adjacency[pre].append(cur)
        
        que = deque()
        for i, val in enumerate(indegrees):
            if not val:
                que.append(i)
        num_c = 0
        while que:
            # print(que)
            num_c+=1
            pre = que.popleft()
            for cur in adjacency[pre]:
                indegrees[cur] -= 1
                if not indegrees[cur]:
                    que.append(cur)
        return num_c == numCourses
```

解法二：dfs，从任一节点遍历

构建邻接表和标志列表

flags:-1:已经遍历过，无须再次遍历；0：还没有遍历；1：正在遍历

环：dfs时出现正在遍历的点

```python
from collections import deque
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        
        def dfs(val):
            if flags[val]==1:
                return False
            if flags[val]==-1:
                return True
            flags[val]=1
            for nex in adjacency[val]:
                if not dfs(nex):
                    return False
            flags[val]=-1
            return True

        adjacency = [[] for _ in range(numCourses)]
        flags = [0]*numCourses
        for cur, pre in prerequisites:
            adjacency[pre].append(cur)
        
        for val in range(numCourses):
            if not dfs(val):
                return False

        return True            
```

## 210. 课程表 II

dfs: 在回朔时将课程加入栈中，此时栈顶课程先于栈底课程完成

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        adajency = [[] for _ in range(numCourses)]
        flag = [0 for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adajency[pre].append(cur)
        res = []
        self.Circle = False
        
        def dfs(index):
            if flag[index]==-1:
                return 
            if flag[index]==1:
                self.Circle = True
                return 
            
            flag[index] = 1
            for val in adajency[index]:
                dfs(val)
            flag[index] = -1
            res.append(index)
        
        for val in range(numCourses):
            if (not self.Circle) and flag[val]==0:
                dfs(val)

        if self.Circle:
            return []
        else:
            return res[::-1]
```

bfs:

```python
from collections import deque
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        adajency = [[] for _ in range(numCourses)]
        indegree = [0 for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adajency[pre].append(cur)
            indegree[cur] += 1
        res = []
        que = deque()
        for val in range(numCourses):
            if indegree[val]==0:
                que.append(val)
        while que:
            index = que.popleft()
            for val in adajency[index]:
                indegree[val] -= 1
                if indegree[val]==0:
                    que.append(val)
            res.append(index)
        if len(res)!=numCourses:
            return list()
        else:
            return res
```

## 208. 实现 Trie (前缀树)

前缀树：结点没有值，边有值，同时每个结点需要word表示是否是单词

```python
# 只涉及 insert, search, startwith的前缀树
from collections import defaultdict
class TrieNode:
    def __init__(self):
        self.children = defaultdict(TrieNode)
        self.word = False

class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()



    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        cur = self.root
        for w in word:
            cur = cur.children[w]

        cur.word = True

    def searchpre(self, word):
        cur = self.root
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        cur = self.searchpre(word)
        
        return cur and cur.word

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        cur = self.searchpre(word)
        return cur!=False
```

```python
# 涉及 insert, search, startwith, delete的前缀树

from collections import defaultdict

class TreeNode:
    def __init__(self):
        self.children = defaultdict(TreeNode)
        self.path = 0 # 表示经过当前结点的单词个数
        self.word = 0 # 表示当前结点为单词结尾的个数

class Trie:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()

    def insert(self, word):
        """
        Inserts a word into the trie.
        :type word: str
        :rtype: void
        """
        cur = self.root
        for w in word:
            cur = cur.children[w]
            cur.path += 1
        cur.word += 1

    def searchpre(self, word):
        cur = self.root
        for w in word:
            if w not in cur.children:
                return False
            cur = cur.children[w]
        return cur

    def search(self, word):
        """
        Returns if the word is in the trie.
        :type word: str
        :rtype: bool
        """
        cur = self.searchpre(word)
        
        return cur and cur.word

    def startsWith(self, prefix):
        """
        Returns if there is any word in the trie that starts with the given prefix.
        :type prefix: str
        :rtype: bool
        """
        cur = self.searchpre(word)
        return cur!=False
    
    def delete(self, word):
        # 假设单词一定出现在前缀树中
        cur = self.root
        for w in word:
            tmp = cur.children[w]
            if cur.children[w].path==1:
                cur.children.pop(w)
            cur = tmp
            cur.path -= 1
        cur.word -= 1

```

## 211. 添加与搜索单词 - 数据结构设计

前缀树

```python
from collections import defaultdict
class TreeNode:
    def __init__(self):
        self.children = defaultdict(TreeNode)
        self.word = False

class WordDictionary:

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TreeNode()


    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        cur = self.root
        for w in word:
            cur = cur.children[w]
        cur.word = True


    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        """
        cur = self.root
        res = self.search2(word, 0, cur)
        return res

    
    def search2(self, word, index, cur):

        if index==len(word):
            return cur.word
        res = False
        if word[index]==".":
            for child in cur.children.values():
                res = res or self.search2(word, index+1, child)
            return res
        
        if word[index] in cur.children:
            return self.search2(word, index+1, cur.children[word[index]])
        return False


# 解法2：
import re
class WordDictionary:

    def __init__(self):
        self.words = '#'
    
    def addWord(self, word):
        self.words += word + '#'

    def search(self, word):
        return bool(re.search('#' + word + '#', self.words))
```

### 212. 单词搜索 II

前缀树

```python
from collections import defaultdict
class TreeNode:
    def __init__(self):
        self.children = defaultdict(TreeNode)
        self.word = None
dx = [0,1,0,-1]
dy = [1,0,-1,0]
class Solution:
    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
        self.root = TreeNode()
        self.build(words)
        self.n, self.m = len(board), len(board[0])
        self.res = list()
        for i in range(self.n):
            for j in range(self.m):
                self.findWords2(board, i, j, self.root)
        return self.res

    def build(self, words):

        def insert(word):
            cur = self.root
            for w in word:
                cur = cur.children[w]
            cur.word = word
        
        for word in words:
            insert(word)
        
        return
    
    def findWords2(self, board, i, j, parent):
        if not self.inArea(i, j):
            return False     
               
        w = board[i][j]
        if w not in parent.children.keys():
            return False

        cur = parent.children[w]
        print(i, j, w)
        if cur.word:
            self.res.append(cur.word)
            cur.word = None

        board[i][j] = '#'
        for ddx, ddy in zip(dx, dy):
            self.findWords2(board, i+ddx, j+ddy, cur)
        board[i][j] = w
        # 优化：如果到了叶子结点，则该结点一定已经加入结果中，并且以后无须再次访问该结点，可以删除叶子结点
        if not cur.children:
            parent.children.pop(w)
    
    def inArea(self, i, j):
        return -1<i<self.n and -1<j<self.m
```

## 213. 打家劫舍 II

dp[n] = max(dp[n-1], dp[n-2]+nums[n])

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        f = [[0, 0] for _ in range(n+1)]
        f[1][1] = nums[0]
        g = [[0, 0] for _ in range(n+1)]
        for i in range(2, n+1):
            f[i][0] = max(f[i-1][1], f[i-1][0])
            f[i][1] = f[i-1][0]+nums[i-1]
            g[i][0] = max(g[i-1][1], g[i-1][0])
            g[i][1] = g[i-1][0]+nums[i-1]
        if n == 1:
            res = max(f[-1][0], f[-1][1])
        else:
            res = max(f[-1][0], g[-1][1])
        return res
        
class Solution:
    def rob(self, nums: [int]) -> int:
        def my_rob(nums):
            cur, pre = 0, 0
            for num in nums:
                cur, pre = max(pre + num, cur), cur
            return cur
        return max(my_rob(nums[:-1]),my_rob(nums[1:])) if len(nums) != 1 else nums[0]

```

## 214. 最短回文串

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

第一步：证明 可以从字符串开头找到最大的回文子串，然后反转剩余的子串并附加到开头

反证法：如果不是，有更短的回文串拼接。根据拼接后的回文串，可以得到更长的字符串开头的最大的回文子串，矛盾。

第二步：KMP找最大反转回文子串。

将原字符串s="abbad"反转 rev="dabba"，找s和rev的相同子串 s[: n-i]=rev[ i:]
或者说，我们需要比较前缀{abbad, abba, abb, ab, a}和后缀{dabba, abba, bba, ba, a}的最大匹配，显然是KMP

“#”防止"aa"-"aaaa"的情况，保证前缀一定出现在字符串s中

```python
class Solution:
    def shortestPalindrome(self, s: str) -> str:
        ss = s+"#"+s[::-1]
        def getnext(s):
            n = len(s)
            nex = [0]*(n+1)
            nex[0]=-1
            i, j =0, -1
            while i<n:
                if j==-1 or s[i]==s[j]:
                    i, j = i+1, j+1
                    nex[i]=j
                else:
                    j = nex[j]
            return nex[-1]
        pos = getnext(ss)
        # print(pos)
        res = s[-1:pos-1:-1]+s
        return res
```

## 第K个最大元素

小顶堆  快速选择

## 220 存在重复元素III

在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的绝对值也小于等于 ķ 。

以t+1为w建立桶，那么问题可以转换为 对于x所在的桶index，如果发生三种情形之一，则存在：

1. index已经有值
2. index-1有值且差小于等于t
3. index+1有值且差小于等于t

显然非相邻桶的差大于t

或者说桶排序使得桶内差距小于t，相邻桶差距小于[0, 2t]，隔一个桶的差距[t, 3t]，隔两个桶的差距[2t, 4t]，缩减了求差的范围。

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        if not nums or t<0:
            return False
        delta = t+1
        min_val = min(nums)
        def getID(val):
            return (val-min_val)//delta
        hashmap = dict()
        for i, val in enumerate(nums):
            if i>k:
                index = getID(nums[i-k-1])
                hashmap.pop(index)            
            index = getID(val)
            if index in hashmap:
                # print(1, index, hashmap)
                return True
            if index-1 in hashmap and val-hashmap[index-1]<=t:
                # print(2, index, hashmap)
                return True
            if index+1 in hashmap and hashmap[index+1]-val<=t:
                # print(3, index, hashmap)
                return True
            hashmap[index]=val
            # print(hashmap)
        return False
```

## 222. 完全二叉树的节点个数

递归法：分别求左右子树的高度，如果leftd==rightd，说明左子树是满二叉树，2^leftd，如果leftd!=rightd，说明右子树是满二叉树，2^rightd

时间复杂度：O(d)=O(lgn)

满二叉树的深度为d，则结点个数为2^d-1

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def getDepth(root):
            depth = 0
            while root:
                root = root.left
                depth += 1
            return depth
            
        leftdp = getDepth(root.left)
        rightdp = getDepth(root.right)
        if leftdp==rightdp:
            leftNodes = 1<<leftdp
            rightNodes = self.countNodes(root.right)
        else:
            leftNodes = self.countNodes(root.left)
            rightNodes = 1<<rightdp
        res = leftNodes+rightNodes
        return res

```

## 224. 计算器 + - * / ( )

### 解法一：将中缀表达式转化为后缀表达式，然后利用逆波兰数解决 推荐

https://blog.csdn.net/sgbfblog/article/details/8001651

使用辅助栈，定义优先级 (:0, ):0, + -:1, * /:2，保证辅助栈严格单调递增
每遇到一个左括号，辅助栈的基本优先级就+3， 每遇到一个右括号，辅助栈的基本优先级就-3，
比如 + * ( + * ( + * ))，基本优先级分别是 0 0 3 3 3 6 6 6 6 3，实际优先级=基本优先级+符号优先级：1 2 3 4 5 6 7 8 6 3
这是因为遇到+ - * /时，辅助栈只需要弹出到+ - * /严格单调递增且左括号不会弹出，且遇到左括号时直接压入辅助栈。所以遇到左括号时，左括号的优先级大于已经入栈的符号，但是小于未入栈的符号+ - * /，所以提出遇到左括号时栈的基本优先级+3，然后在此基础上计算未入栈的符号的优先级。
当遇到右括号时，辅助栈需要一直弹出，直到(，并且弹出之后( 之后辅助栈的基本优先级需要-3，并且此时exp2的末尾插入了左括号，需要弹出。

一、 将中缀表达式转换成后缀表达式算法：
　　1、从左至右扫描一中缀表达式。
　　2、若读取的是操作数，则判断该操作数的类型，并将该操作数存入操作数堆栈
　　3、若读取的是运算符
　　　　(1) 该运算符为左括号"("，则直接存入运算符堆栈。
　　　　(2) 该运算符为右括号")"，则输出运算符堆栈中的运算符到操作数堆栈，直到遇到左括号为止。
　　　　(3) 该运算符为非括号运算符：
　　　　　　(a) 若运算符堆栈栈顶的运算符为括号（只可能是左括号），则直接存入运算符堆栈。
　　　　　　(b) 若比运算符堆栈栈顶的运算符优先级高，则直接存入运算符堆栈。
　　　　　　(c) 若比运算符堆栈栈顶的运算符优先级低或相等，则不断输出栈顶运算符到操作数堆栈，直到栈顶没有运算符的优先级大于或者等于当前预算符（即栈顶存在运算符的话，优先级一定是小于当前运算符），最后将当前运算符压入运算符堆栈。
　　4、当表达式读取完成后运算符堆栈中尚有运算符时，则依序取出运算符到操作数堆栈，直到运算符堆栈为空。

二、逆波兰表达式求值算法：
　　1、从左到右依次扫描语法单元的项目。
　　2、如果扫描的项目是操作数，则将其压入操作数堆栈，并扫描下一个项目。
　　3、如果扫描的项目是一个二元运算符，则对栈的顶上两个操作数执行该运算。
　　4、如果扫描的项目是一个一元运算符，则对栈的最顶上操作数执行该运算。
　　5、将运算结果重新压入堆栈。
　　6、重复步骤2-5，堆栈中即为结果值。

逆波兰求解：如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。


```python
def ToSuffixExpression(exp1):
    exp2 = list()
    stack = list()
    pri = {"+":1, "-":1, "*":2, "/":2, "(":0, ")":0}
    base = 0
    delta_base = 3
    for val in exp1:
        print("val", val)
        if val.isdigit():
            exp2.append(val)
        else:
            if val == "(":
                base+=delta_base
            pri_val = base+pri[val]
            while stack and pri_val<=stack[-1][1]:
                exp2.append(stack.pop()[0])
            stack.append((val, pri_val))
            if val in [")"]:
                exp2.pop()
                stack.pop()
                base-=delta_base
        print("exp2", exp2)
        print("stack", stack)
    while stack:
        exp2.append(stack.pop()[0])
    print(exp2)
    return exp2
```

### 解法二：双栈 推荐 通用

stack_dig 保存数字， stack_op 保存操作符
左括号优先级+3，右括号优先级-3
stack_op 操作符优先级严格单调递增

```python
class Solution:
    def calculate(self, s: str) -> int:
        s = "(" + s + ")"
        n = len(s)
        stack_dig = []
        stack_op = []
        pri = {"(":0, ")":0, "+":1, "-":1, "*":2, "/":2}
        base, base_pri = 0, 3
        dig_cur, dig_flag = 0, False
        for val in s:
            if val.isdigit():
                dig_cur = dig_cur*10+int(val)
                dig_flag = True
            elif val!=" ":
                if dig_flag:
                    stack_dig.append(dig_cur)
                    dig_cur, dig_flag = 0, False
                if val=="(":
                    base = base+base_pri
                pri_val = base+pri[val]
                while stack_op and pri_val<=stack_op[-1][1]:
                    self.eval_expr(stack_dig, stack_op)
                stack_op.append((val, pri_val))
                if val==")":
                    stack_op.pop()
                    base = base-base_pri 
                # print("dig:", stack_dig, "op:", stack_op)
        return stack_dig[-1]
    
    def eval_expr(self, stack_dig, stack_op):
        op = stack_op.pop()[0]
        if op=="(":
            return
        num2 = stack_dig.pop()
        num1 = stack_dig.pop()

        if op=="+":
            res = num1+num2
        elif op=="-":
            res = num1-num2
        stack_dig.append(res)
        return 
```

### 解法三：括号用递归 推荐

左右括号进递归，加减入栈，乘除计算

```python
from collections import deque
def calculate(s):
    s = deque(s)
    def helper(s):

        stack = []
        sign = "+"
        num = 0
        while len(s)>0:
            c = s.popleft()
            if c.isdigit():
                num = 10*num+int(c)
            if c=="(":
                num = helper(s)
            if c in ["+", "-", "*", "/"] or len(s)==0:
                if sign == "+":
                    stack.append(num)
                if sign == "-":
                    stack.append(-num)
                if sign == "*":
                    pre = stack.pop()
                    stack.append(pre*num)
                if sign == "/":
                    pre = stack.pop()
                    stack.append(pre//num)
                num, sign = 0, c
            if c==")":
                break
        return sum(stack)
    return helper(s)
```

## 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/m ⌋ 次的元素。

摩尔投票法

证明：考虑m=3。假设hashmap剩下2个候选数字，cand1：k1, cand2：k2, 其余数字满足 每三个不同的数字成一对。对于不同于cand1，cand2的数字x，则x的次数最多为(n-k1-k2)//3<= n //3。假设hashmap剩下1个候选数字，cand1：k1，其余数字满足 每三个不同的数字成一对。对于不同于cand1的数字x，则x的次数最多为(n-k1)//3<= n //3。

```python
from collections import defaultdict
class Solution:
    def majorityElement(self, nums: List[int], m) -> List[int]:
        hashmap = defaultdict(int)
        n = len(nums)
        for val in nums:
            print(hashmap)
            if val in hashmap:
                hashmap[val] = hashmap[val]+1
            elif len(hashmap)<m:
                hashmap[val] = 1
            else:
                for k, v in hashmap.copy().items():
                    hashmap[k] -= 1
                    if hashmap[k] == 0:
                        hashmap.pop(k)
        hashmap2 = defaultdict(int)
        for val in nums:
            if val in hashmap:
                hashmap2[val] += 1
        res = []
        for k, v in hashmap2.items():
            if v>n//m:
                res.append(k)
        print(hashmap, hashmap2)
        return res
```

## 233. 数字 1 的个数

将数字n分为，abc，比如234，a=2， b=3，c=4

当b=0时，204, b位上1的个数：010-019，110-119, =a*10
b=1时，214，b位上1的个数：010-019，110-119, 210-214 =a*10+c+1
b=2-9时，234，b位上1的个数：010-019，110-119, 210-219，=a*10+10

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        res = 0
        base = 1
        while base<=n:
            a, b, c = (n//base)//10, (n//base)%10, n%base
            if b==0:
                res+=a*base
            elif b==1:
                res+=a*base+c+1
            else:
                res+=(a+1)*base
            base = base*10
        return res
```

## 236 二叉树的两个结点的最低公共祖先

https://zhuanlan.zhihu.com/p/43681377

最低公共祖先LCA：如果有两个结点，那么求最低公共祖先，如果只出现了一个结点，那么求该结点

定义f(root):返回以root为根结点的树的最低公共祖先LCA

f(root) = (root.val==p or root.val==q) or (f_left and f_right)

如果root.val==p或者q，则root为LCA
如果f_left或者f_right都不是LCA，则root不是LCA
如果f_left或者f_right只有一个是LCA，则f(root)=f_left or f_right
如果f_left和f_right 都是LCA，则root也是LCA，

```python
def demo1(root, a1, a2):
    if not root:
        return None
    if root.val==a.val or root.val==b.val:
        return root
    left_lca = demo1(root.left, a1, a2)
    right_lca = demo1(root.right, a1, a2)
    if left_lca and right_lca:
        return root
    return left_lca or right_lca
```

## 239. 滑动窗口最大值

解法一：单调递减双向队列

```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        que = deque()
        res = []
        for i, val in enumerate(nums):
            while que and i-que[0]>=k:
                que.popleft()
            while que and val>nums[que[-1]]:
                que.pop()
            que.append(i)
            res.append(nums[que[0]])
        return res[k-1:]
```

解法二： 动态规划

https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/

以k=3，nums=[1,2,3,4,5,6,7]为例，将nums按照k个一组分别划分为 [1,2,3][4,5,6][7]
同时求left[i]:每块开始到i的最大值，right[j]：每块结尾到i的最大值
对于在同一个块[ 1 2 3 ]的元素i=0, j=2，滑动窗口最大值为 left[j]=max(right[i], left[j])
对于在相邻块块0块1 [2,3,4]的元素i=1，j=3，滑动窗口最大值为 max(right[i], left[j]): 块0结尾到i的最大值，块1开始到j的最大值

这个和 数组排序之后相邻数的最大差值、存在重复元素III(距离小于等于k的相邻数字的最大差小于等于t)有异曲同工之处。
暂时没有更好的解释

```python
from collections import deque
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        left = [0 for _ in range(n)]
        left[0] = nums[0]
        right = [0 for _ in range(n)]
        right[-1] = nums[-1]
        for i in range(n):
            if i%k==0:
                left[i] = nums[i]
            else:
                left[i] = max(left[i-1], nums[i])
            j = n-1-i
            if (j+1)%k==0 or j+1==n:
                right[j] = nums[j]
            else:
                right[j] = max(right[j+1], nums[j])
        res = []
        for j in range(k-1, n):
            i = j-(k-1)
            res.append(max(right[i], left[j]))
        return res
```

## 241. 为运算表达式设计优先级

https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/c-fen-zhi-dong-tai-gui-hua-by-xing-chen-da-hai-36/

首先将字符串分解为数字nums和操作符ops
dp[i][j]表示从第i个数字到第j个数字的所有情况
（1）i==j
等于数字本身的值
（2）i!=j(j肯定是大于i的) 
将i-j分成两个式子来看，[i,i]op[i+1,j],[i,i+1]op[i+2,j]...[i,j-1]op[j,j]
dp[i][j] = dp[i][m]ops[m]dp[m+1][j], m=i,...,j-1，其中dp[i][j]是列表，不是数字

```python
class Solution:
    def diffWaysToCompute(self, input: str):
        ops = []
        nums = []
        num = 0
        for val in input:
            if self.isOP(val):
                ops.append(val)
                nums.append(num)
                num = 0
            else:
                num = num*10+int(val)
        nums.append(num)
        n = len(nums)
        
        dp = [[list() for _ in range(n)] for _ in range(n)]
        for i in range(n):
            dp[i][i] = [nums[i]]
        # print("first", dp)

        for k in range(1, n):
            for i in range(0, n-k):
                j = k+i
                self.calculate_dp(i, j, dp, ops)
                # print("se", dp)
        return dp[0][-1]

    def calculate_dp(self, i, j, dp, ops):
        for m in range(i, j):
            for left in dp[i][m]:
                for right in dp[m+1][j]:
                    dp[i][j].append(self.calculate(left, ops[m],right))

                    
    def calculate(self, num1, op, num2):
        if op=="+":
            return num1+num2
        elif op=="-":
            return num1-num2
        elif op=="*":
            return num1*num2

    def isOP(self, val):
        return val in ["+", "-", "*"]
```

## 中心对称数

### 246 中心对称数I

中心对称数是指一个数字在旋转了180 度之后看起来依旧相同的数字

比如96，88，

```python
def demo1(nums:int):
    nums = str(nums)
    map = {0:0, 1:1, 2:-, 3:-, 4:-, 5:-, 6:9, 7:-, 8:8, 9:6}
    n = len(nums)
    for i, val in enumerate(nums):
        if map[val]=="-" or map[val]!==nums[n-1-i]:
            return False
    return True        
```

### 247 中心对称数II

找到所有长度为 n 的中心对称数。

思路一：
对于 n 是奇数的解来说，
只要在 n - 1的解的每个数中间 加上 0 或 1 或 8 就可以得到 n 的解。
对于 n 是偶数的解来说，
只要在 n - 2 的解的每个数中间加上 00 ， 11， 88， 69， 96就可以得到n 的解。

```python
def demo2(n: int):
    res = [[], ["0", "1", "8"], ["11", "88", "96", "69"]]
    if n<=2:
        return res[n]
    pair = [[], ["0", "1", "8"], ["00", "11", "88", "96", "69"]]
    for i in range(3, n+1):
        j = 2-i%2
        for val1 in res[i-j]:
            for val2 in pair[j]:
                res.append(val1[:i//2]+val2+val1[i//2:])
    return res[-1]
```

思路二：
f(n) = f(n-2)+["00", "11", "88", "96", "69"] 在两端分别加上["00", "11", "88", "96", "69"],且对于n，两端不能加00，

n=0: ""
n=1: "0", "1", "8"
n=2: "00", "11", "88", "96", "69"

```python
def demo2(n: int):

    def helper(m:int):
        if m==0:
            return [""]
        if m==1:
            return ["0", "1", "8"]
        pre = helper(m-2)
        res = []
        for val in pre:
            if m!=n:
                res.append("0"+val+"0")
            for first, final in ["11", "88", "96", "69"]
                res.append(first+val+final)
        return res
    res = helper(n)
    return res            
```

### 248 中心对称数III

求[low, high]之间的中心对称数的个数

思路一：

先调一下247. 中心对称数 II的答案，得到从 长度在【0，len(high)】 之间的所有中心对称数， 并按长度分好类。
然后问题就变成了，在长度为 len(low)的所有中心对称数里，比 low 大的有几个？在长度为 len(high)的所有中心对称数里，比 high 小的有几个？这俩问题用二分查找就可以解决，然后再根据 len(low) 和 len(high）长度的关系返回输出即可。

```python

class Solution(object):
    def strobogrammaticInRange(self, low, high):
        """
        :type low: str
        :type high: str
        :rtype: int
        """
        if int(low) > int(high):
            return 0
        self.findStrobogrammatic(len(high)) 
        
        #找在low_rec里有多少个数 >= low，结果放在low_cnt里
        #这里相当于在找左侧边界
        low_rec = self.record[len(low)]
        low_cnt = len(low_rec) - bisect.bisect_left(low_rec, low)
        
        #找在hige_rec里有多少个数<= high, 结果放在high_cnt里
        #这里相当于在找右侧边界
        high_rec = self.record[len(high)]
        high_cnt = bisect.bisect_right(high_rec, high)
 
        if len(low) + 1 == len(high): #如果相邻的长度，则直接相加
            return low_cnt + high_cnt
        elif len(low) == len(high): #如果长度相同，那么减去重复计算的部分
            return low_cnt + high_cnt - len(high_rec)
        else: #如果相隔超过1，则相加之后再加上所有中间结果的长度之和
            tmp = 0
            for l in range(len(low) + 1, len(high)):
                tmp += len(self.record[l])
            return tmp + low_cnt + high_cnt
 
    def findStrobogrammatic(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        self.record = dict()
        self.record[0] = ["0"]
        self.record[1] = ["0", "1", "8"]
        self.record[2] = ["11", "69", "88", "96"]
        pair = ["00", "11", "88", "69", "96"]
        if n <= 2:
            return self.record[n]
        cnt = 3
        while cnt <= n:
            tmp = []
            if (cnt - 1) % 2 == 0: #如果前一个是偶数长度，那么直接在中间加长度为1的就可以
                for item in self.record[cnt - 1]:
                    for num in self.record[1]:
                        tmp.append(item[:len(item)// 2] + num + item[len(item) // 2:])
            else:                  #如果前一个是奇数长度，那么就在中间加长度为2的就可以 ，注意要额外加“00”
                for item in self.record[cnt - 2]:
                    for num in pair:
                        tmp.append(item[:len(item)// 2] + num + item[len(item) // 2:])
            self.record[cnt] = sorted(tmp, key = lambda x: int(x))
            cnt += 1
```

思路二：

从 n=0 和 n=1 的中心对称数开始，在每个数两端加上00，11，88，69，96。得到的数num一定也是中心对称数，所以只需要判断num是否在[low, high]内即可

```java

class Solution {
public:
    string low, high;
    int cnt;
 
    int strobogrammaticInRange(string low, string high) {
        this->low = low;
        this->high = high;
        cnt = 0;
        solve("");
        solve("0");
        solve("1");
        solve("8");
        return cnt;
    }
 
    void solve(string num) {
        if((num.size() > high.size()) ||                 // 递归边界：若num的长度 > high的长度
           (num.size()==high.size() && num > high))      // 或长度相等,但num比high大 (string可用>直接比较)
            return;
 
        // 若num在[low,high]内, 就计数
        if(!(num.size()>1 && num[0]=='0') &&             // num开头不是0
           ((num.size() > low.size()) ||
            (num.size()==low.size() && num>=low))        // 且num>=low (string可用>直接比较)
        )
            ++cnt;
 
        solve("0" + num + "0");
        solve("1" + num + "1");
        solve("8" + num + "8");
        solve("6" + num + "9");
        solve("9" + num + "6");
    }

```

## 243 最短的单词距离II

Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Input: word1 = “coding”, word2 = “practice”
Output: 3
Input: word1 = "makes", word2 = "coding"
Output: 1
多次调用word1和word2

```java
class WordDistance {
public:
    WordDistance(vector<string>& words) {
        for (int i = 0; i < words.size(); ++i) {
            m[words[i]].push_back(i);
        }
    }

    int shortest(string word1, string word2) {
        int i = 0, j = 0, res = INT_MAX;
        while (i < m[word1].size() && j < m[word2].size()) {
            res = min(res, abs(m[word1][i] - m[word2][j]));
            m[word1][i] < m[word2][j] ? ++i : ++j;
        }
        return res;
    }
    
private:
    unordered_map<string, vector<int> > m;
};
```

## 244 最短的单词距离III

Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Input: word1 = “coding”, word2 = “practice”
Output: 3
Input: word1 = "makes", word2 = "coding"
Output: 1
word1和word2可能相同

用idx记录上一次的情况，i表示当前情况
当word1==word2时，idx和i分别表示相邻两次遇到单词word1的位置，计算res
当word1!=word2时，分为两种情况：word[idx]==word[i],更新idx即可；word[idx]!=word[i]，计算res


```java
class Solution {
public:
    int shortestWordDistance(vector<string>& words, string word1, string word2) {
        int idx = -1, res = INT_MAX;
        for (int i = 0; i < words.size(); ++i) {
            if (words[i] == word1 || words[i] == word2) {
                if (idx != -1 && (word1 == word2 || words[i] != words[idx])) {
                    res = min(res, i - idx);
                }
                idx = i;
            }
        }
        return res;
    }
};
```

## 253 会议室II

给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],...] (si < ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

https://www.cnblogs.com/grandyang/p/5244720.html

解法一：

使用 TreeMap 来做的，遍历时间区间，对于起始时间，映射值自增1，对于结束时间，映射值自减1，然后定义结果变量 res，和房间数 rooms，遍历 TreeMap，时间从小到大，房间数每次加上映射值，

```java
class Solution {
public:
    int minMeetingRooms(vector<vector<int>>& intervals) {
        map<int, int> m;
        for (auto a : intervals) {
            ++m[a[0]];
            --m[a[1]];
        }
        int rooms = 0, res = 0;
        for (auto it : m) {
            res = max(res, rooms += it.second);
        }
        return res;
    }
};
```

解法二：

第二种方法是用两个一维数组来做，分别保存起始时间和结束时间，然后各自排个序，定义结果变量 res 和结束时间指针 endpos，然后开始遍历，如果当前起始时间小于结束时间指针的时间，则结果自增1，反之结束时间指针自增1，这样可以找出重叠的时间段，从而安排新的会议室，

```java

class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals == null || intervals.length == 0) return 0; 
        int[] start = new int[intervals.length];
        int[] end = new int[intervals.length];
        for(int i=0;i<intervals.length;i++){
            start[i] = intervals[i][0];
            end[i] = intervals[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);
        
        int rooms=0, activeMeeting = 0;
        int i=0,j=0;
        while(i<intervals.length && j<intervals.length){
            if(start[i]<end[j]){
                activeMeeting++;
                i++;
            }else{
                activeMeeting--;
                j++;
         }
            rooms = Math.max(rooms,activeMeeting);
        }
        return rooms;
        
    }
```

解法三：

最小堆minHeap，先按start排序，然后维护一个minHeap，堆顶元素是会议结束时间最早的区间，也就是end最小。每次比较top元素的end时间和当前元素的start时间，如果end < start，说明该room可以结束接下来被当前会议区间使用。最后返回堆的大小就是所需的房间数。

```python
public class Solution {
   public int minMeetingRooms(Interval[] intervals) {   
     int n=intervals.length;   
     Arrays.sort(intervals, new Comparator<Interval>(){ 
         public int compare(Interval a, Interval b) {   
           return a.start-b.start;   
         } 
     });   
     PriorityQueue<Integer> pq=new PriorityQueue<>();   
     for (int i=0; i<n; i++) {   
       if (i>0 && intervals[i].start>=pq.peek()) pq.poll();   
       pq.add(intervals[i].end);   
     }   
     return pq.size();   
   }   
 } 
```

## 255 验证前序遍历序列二叉搜索树（二叉树）

维持一个有下界的单调递减栈(单调栈)：当元素大于栈顶时，表示该元素是子树的右节点，弹出子树的根和左节点，更新下界，压入右节点。
当弹出子树的根和左节点时，可以理解成子树的右节点代替子树
??? 还是很难理解

```python
class Solution {
public:
    bool verifyPreorder(vector<int>& preorder) {
        if (!preorder.size()) return true;
        stack<int> st;
        st.push(preorder[0]);
        int lst = INT_MIN;
        for (int i=1;i<preorder.size();i++)
        {
            if (preorder[i] < lst) return false;
            while(!st.empty() && preorder[i] > st.top()) 
            {
                lst = max(lst, st.top());
                st.pop();
            }
            st.push(preorder[i]);
        }
        return true;
    }
};
```

## 大楼轮廓问题

解法一：红黑树 multiset

参考链接：https://www.jianshu.com/p/36dcb18525a1

思路：
cur_H: 表示未完成大楼轮廓中所有的左墙高度，有序
pre: 表示未完成大楼轮廓的起点
(l, r, h)-->(l,-h), (r,h)
核心思想：每次确定一小段可以完成的大楼轮廓
第一：左墙入 cur_H，右墙出 cur_H
第二：当cur_H的高度发生变化时，画出一个轮廓

对于相同位置的左墙，先入高墙-10，后入矮墙-5
对于相同位置的右墙，先出矮墙5，后出高墙10

这里作者使用了**红黑树**来实现比较快的 查找(取最大)，插入，删除 操作O(log n)。

```c++
class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        multiset<pair<int, int>> all;
        vector<vector<int>> res;
        
        for (auto& e : buildings) {
            all.insert(make_pair(e[0], -e[2])); // critical point, left corner
            all.insert(make_pair(e[1], e[2])); // critical point, right corner
        }
        
        multiset<int> heights({0}); // 保存当前位置所有高度。
        int prev=0; // 保存上一个位置的高度
        for (auto& p : all) {
            if (p.second < 0) heights.insert(-p.second); // 左端点，高度入堆
            else heights.erase(heights.find(p.second)); // 右端点，移除高度
            
            // 当前关键点，最大高度
            auto maxHeight = *heights.rbegin();
            
            // 当前最大高度如果不同于上一个高度，说明这是一个转折点
            if (prev!=maxHeight) {
                // 更新prev和结果
                res.push_back({l.first, maxHeight}); 
                prev = maxHeight; 
            }
        }
        
        return res;
    }
};

```

解法二：小顶堆

heap：小顶堆(h, r)，表示所有未完成的大楼高度及对应终止坐标，和部分已经完成的大楼高度及对应终止坐标，并且保证小顶堆的堆顶的大楼高度一定是未完成的

(l, r, h)-->左(l, -h, r), 右(r, 0, -1)

因为右端点也可能造成大楼轮廓，所以需要保留右端点
入堆：左端点
出堆：左右端点导致的无效轮廓
记录：当小顶堆堆顶高度发生变化时


```python
import heapq
import sys
class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        points = []
        for l, r, h in buildings:
            points.append((l, -h, r))
            points.append((r, 0, -1))
        points.sort()
        heap = [(0, sys.maxsize)]
        res = []
        prev = 0
        for l, h, r in points:
            while l>=heap[0][1]:
                heapq.heappop(heap)
            if h<0:
                heapq.heappush(heap, (h, r))
            if prev!=heap[0][0]:
                prev = heap[0][0]
                res.append([l, -prev])
        return res
```

## 259. 较小的三数之和

排序+双指针(left, right)

```python
class Solution(object):
    def threeSumSmaller(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        N = len(nums)
        res = 0
        nums.sort()
        for i, num in enumerate(nums):
            x = target - num
            left, right = i+1, N-1
            while(left < right):
                tmp = nums[left]+nums[right]
                if  tmp >= x:
                    right -= 1
                else:
                    res += right-left
                    left += 1
        return res
```

## 260. 只出现一次的数字 III

```python
class Solution:
    def singleNumber(self, nums: int) -> List[int]:
        # difference between two numbers (x and y) which were seen only once
        bitmask = 0
        for num in nums:
            bitmask ^= num
        
        # rightmost 1-bit diff between x and y
        diff = bitmask & (-bitmask)
        
        x = 0
        for num in nums:
            # bitmask which will contain only x
            if num & diff:
                x ^= num
        
        return [x, bitmask^x]
```

## 261 以图判树

并查集: 只有一个根，没有环

```python
class UnionFindSet(object):
    def __init__(self, n):
        self.count = n
        self.roots = [i for i in range(n)]
        
    def find(self, node):
        while self.roots[node] != node:
            node = self.roots[node]
        return node
    
    def union(self, p, q):
        p_parent = self.find(p)
        q_parent = self.find(q)
        self.roots[p_parent] = q_parent
        self.count -= 1
        
class Solution(object):
    def validTree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: bool
        """
        #开并查集，如果一条边的两个顶点在放进图之前就有相同的根结点，则说明这条边放进去之后会形成一个环
        ufs = UnionFindSet(n)
        for start, end in edges:
            if ufs.find(start) == ufs.find(end):
                return False
            ufs.union(start, end)
        # print ufs.count
        return ufs.count == 1
```

## 265 粉刷房子II

对于每一个房子，保存最小花费MIN和次最小花费2_MIN。对于下一个房子，涂某种油漆时不能使用MIN，即油漆号等于MIN所对应的油漆号时，此时只能使用2_MIN。除此之外，都使用MIN。时间复杂度 O(nk)

```java
class Solution {
public:
    int minCostII(vector<vector<int>>& costs) {
        if(costs.size()==0 or costs[0].size()==0){
            return 0;
        }
        int pre_min_index=-1,pre_min_cost=0,pre_2min_cost=0;
        for(int i=0;i<costs.size();++i){
            int cur_min_index,cur_min_cost=INT_MAX,cur_2min_cost=INT_MAX;
            for(int j=0;j<costs[0].size();++j){
                if(j!=pre_min_index){
                    costs[i][j]+=pre_min_cost;
                }
                else{
                    costs[i][j]+=pre_2min_cost;
                }
                if(costs[i][j]<cur_min_cost){
                    cur_2min_cost=cur_min_cost;
                    cur_min_cost=costs[i][j];
                    cur_min_index=j;
                }
                else if(costs[i][j]<cur_2min_cost){
                    cur_2min_cost=costs[i][j];
                }
            }
            pre_min_index=cur_min_index;
            pre_min_cost=cur_min_cost;
            pre_2min_cost=cur_2min_cost;
            // cout<<pre_min_index<<" "<<pre_min_cost<<" "<<pre_2min_cost<<endl;
        }
        return pre_min_cost;
    }
};

```

## 269 Alien Dictionary 火星词典

思路：

大致思路就是根据字母出现的顺序先构造出图来，
然后进行一下拓扑排序就可以了

构造图的过程就是遍历字符串，
找到第i个和第i+1个字符串第一对不同的字母，然后建立一对关系。

建立完图排一个拓扑序就ok了。

```python
from collections import deque
def alienOrder(words:list[int]):
    in_degree, parents, cnt = initGraph(words)
    res = topology_sort(in_degree, parents, cnt)
    return res

def initGraph(words):
    in_degree = [-1 for _ in range(26)]
    parents = [[] for _ in range(26)]
    cnt = 0
    for c in words[0]:
        index = ord(c)-ord('a')
        if in_degree[index]==0:
            in_degree[index]=1
            cnt+=1
        
    for i in range(1, len(words)):
        for c in words[i]:
            index = ord(c)-ord('a')
            if in_degree[index]==0:
                in_degree[index]=1
                cnt+=1
        for j in range(len(words[i-1])):
            if words[i-1][j]==words[i][j]:
                continue
            parents[ord(words[i-1][j])-ord('a')].append(ord(words[i][j])-ord('a'))
            in_degree[ord(words[i][j])-ord('a')]+=1
            break
    
    return in_degree, parents, cnt

def topology_sort(in_degree, parents, cnt):
    que = deque()
    for val in in_degree:
        if val==0:
            que.append(val)
    res = list()
    while que:
        cur = que.popleft()
        res.append(chr(cur+ord('a')))
        for val in parents[cur]:
            in_degree[val]-=1
            if in_degree[val]==0:
                que.append(val)
    if len(res)==cnt:
        return res
    else:
        return list()
```

## 271. 字符串的编码与解码

编码：字符串长度+特殊字符+字符串 或者 字符串长度(固定占四个字节)+字符串

```python
class Codec:
    def len_to_str(self, x):
        """
        Encodes length of string to bytes string
        """
        x = len(x)
        bytes = [chr(x >> (i * 8) & 0xff) for i in range(3, -1, -1)]
        bytes_str = ''.join(bytes)
        return bytes_str
    
    def encode(self, strs):
        """Encodes a list of strings to a single string.
        :type strs: List[str]
        :rtype: str
        """
        # encode here is a workaround to fix BE CodecDriver error
        return ''.join(self.len_to_str(x) + x for x in strs).encode('utf-8')
        
    def str_to_int(self, bytes_str):
        """
        Decodes bytes string to integer.
        """
        result = 0
        for ch in bytes_str:
            result = result * 256 + ord(ch)
        return result
    
    def decode(self, s):
        """Decodes a single string to a list of strings.
        :type s: str
        :rtype: List[str]
        """
        i, n = 0, len(s)
        s = s.decode("utf-8")
        output = []
        while i < n:
            length = self.str_to_int(s[i: i + 4])
            i += 4
            output.append(s[i: i + length])
            i += length
        return output
```

## 272 二叉搜索树中最接近的值 II

思路一：中序遍历+二分搜索最接近值+左右指针 O(N)

```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
 
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        if root is None or k == 0:
            return []
             
        nums = self.get_inorder(root)
        left = self.find_lower_index(nums, target)
        right = left + 1
        results = []
        for _ in range(k):
            if (right >= len(nums)) or (left >=0 and target - nums[left] < nums[right] - target):
                results.append(nums[left])
                left -= 1
            else:
                results.append(nums[right])
                right += 1
        return results
         
    def get_inorder(self, root):
        result = []
        stack = []
        node = root
        while stack or node:
            if node:
                stack.append(node)
                node = node.left
            else:
                node = stack.pop()
                result.append(node.val)
                node = node.right
        return result
         
         
    def find_lower_index(self, nums, target):
        """
        find the largest number < target, return the index
        """
        start, end = 0, len(nums) - 1
        res = -1
        while start <= end:
            mid = (start + end) // 2
            if nums[mid] < target:
                res = mid
                start = mid+1
            else:
                end = mid-1
             
        return res
```

思路二：中序遍历+窗口为k的队列+提前截止 O(n)
https://zhuanlan.zhihu.com/p/125724782
根据思路一，最后的结果一定是以target为中心的连续k个数字
窗口为k的队列：从中序遍历开始，维持窗口为k的队列，如果当前值-target大于队首-target，弹出队首，加入当前值，反之，说明root后面的值都太大，提前截止

```python
from collections import deque
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        self.que = deque()
        self.k = k
        self.target = target

    def inorder(self, root, ):
        if not root:
            return False
        if self.inorder(root.left):
            return True 
        if len(self.que)<self.k:
            self.que.append(root.val)
            return False
        if abs(self.target - self.que[0]) > (root.val-self.target):
            self.que.popleft()
            self.que.append(root.val)
        else:
            return True
        if self.inorder(root.right):
            return True
        return False
```

思路三：中序遍历+二分查找最接近值+O(H)查找前驱和后继

首先查找最接近值，然后查找k个前驱和后继，然后合并，用哈希表father保存父结点 O(H)

前驱：
如果cur有左子树，则左子数的最右结点就是前驱结点
如果cur没有左子数，则从下往上找祖父结点：满足祖父结点是其父节点的右子树，则祖父结点的父结点是前驱结点

后继：
如果cur有右子树，则右子树的最左结点就是后继结点
如果cur没有右子树，则从下往上找祖父结点：满足祖父结点是其父结点的左子树，则祖父结点的父结点是后继结点

父结点father不需要刻意保存，只需要在访问结点时保存即可

```python
import sys
from collections import defaultdict
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @param k: the given k
    @return: k values in the BST that are closest to the target
    """
    def closestKValues(self, root, target, k):
        self.target = target
        self.k = k
        self.father = {root:None}
        self.closestNode = [None, sys.maxsize]
        self.search2(root)
        res = [self.closestNode[0].val]
        pre, pro = self.getPrecursor(self.closestNode[0]), self.getSuccessor(self.closestNode[0])
        for i in range(k-1):
            if (not pro) or (pre and abs(pre.val-target)<abs(pro.val-target)):
                res.append(pre.val)
                pre = self.getPrecursor(pre)
            else:
                res.append(pro.val)
                pro = self.getSuccessor(pro)
        return res


    def search2(self, root):
        if not root:
            return
        if abs(self.root.val-self.target)<self.closestNode[1]:
            self.closestNode = [root, abs(self.root.val-self.target)]
        if root.val==self.target:
            return
        if root.left and root.val>self.target:
            self.father[root.left]=root
            self.search2(root.left)
        if root.right and root.val<self.target:
            self.father[root.right]=root
            self.search2(root.right)
    
    def getPrecursor(self, root):
        if root.left:
            self.father[root.left]=root
            res = root.left
            while res.right:
                self.father[res.right]=res
                res = res.right
            return res
        while self.father[root] and self.father[root].right.val!=root.val:
            root = self.father[root]
        return self.father[root]
    
    def getSuccessor(self, root):
        if root.right:
            self.father[root.right]=root
            root = root.right
            while root.left:
                self.father[root.left]=root
                root = root.left
        while self.father[root] and self.father[root].left.val!=root.val:
            root = self.father[root]
        return self.father[root]
```

## 273. 整数转换英文表示

每三位划分为一组；对于三位数，划分为百位+两位；对于两位数：分为0-9， 10-19， 20-99.
对于thousand，million， billion，分别对应位置补充即可，
在最后结果中将0对应的空字符串去掉，比如1000中，后三位的000不表示

```python
class Solution:
    def numberToWords(self, num: int) -> str:
        to19 = 'One Two Three Four Five Six Seven Eight Nine Ten Eleven Twelve ' \
               'Thirteen Fourteen Fifteen Sixteen Seventeen Eighteen Nineteen'.split()
        tens = 'Twenty Thirty Forty Fifty Sixty Seventy Eighty Ninety'.split()

        def helper(num):
            if num < 20:
                return to19[num - 1:num]
            if num < 100:
                return [tens[num // 10 - 2]] + helper(num % 10)
            if num < 1000:
                return [to19[num // 100 - 1]] + ["Hundred"] + helper(num % 100)
            for p, w in enumerate(["Thousand", "Million", "Billion"], 1):
                if num < 1000 ** (p + 1):
                    return helper(num // 1000 ** p) + [w] + helper(num % 1000 ** p)

        return " ".join(helper(num)) or "Zero"
```

## 274. H 指数

H指数：大于等于h的论文数量大于等于h，或者说，

方法一：排序：将论文降序排序，cita[i]>=i+1，找到最大的i+1， O(nlgn)

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations= sorted(citations, reverse=True)
        i = 0
        while (i < len(citations) and citations[i] > i) :
            i+=1
        return i
```

引用i+1从小到大1~n，citations[i] >= i+1保证了对于引用i+1，至少有0~i的论文大于等于引用i+1
[6,5,4,1,0]-->[True, True, True, False, False, False]，找最后一个T，返回i+1

方法二：计数排序

因为即便论文的引用次数超过n，h指数也不可能超过n，所以将引用次数超过n的论文视为引用次数为n不影响最后结果

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        h = [0 for _ in range(n+1)]
        for val in citations:
            h[min(n, val)] += 1
        tmp = 0
        for k in range(n, -1, -1):
            tmp +=  h[k]
            if tmp>=k:
                break
        return k
```

对h从大到小遍历n~0，同时记录大于等于h的论文总数量sum，直到sum>=k
[0,1,4,5,6]-->计数排序得[1,1,0,0,1,2]-->[5,4,3,3,3,2]-->[T,T,T,T(res),F,F]，找最后一个T

## 275 H指数 II

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        if not citations:
            return 0
        n = len(citations)
        left, right = 0, n-1
        res = 0
        while left<=right:
            mid = (left+right)//2
            if citations[mid]>=n-mid:
                res = n-mid
                right = mid-1
            else:
                left = mid+1
        return res
```

citations[mid]>=n-mid：对于引用次数大于等于n-i的文章数量大于等于n-i

0,1,4,5,6-->n-i:5,4,3,2,1-->F,F,T,T,T 找到第一个T

## 277 搜寻名人  

https://www.dazhuanlan.com/2019/12/13/5df2f91dacafd/

https://www.cnblogs.com/grandyang/p/5310649.html

名人有两个条件：第一：所有人都认识他，第二：他不认识所有人；并且很明显，名人只能有一个。
对于know(a, b):如果为True，则a一定不是名人；如果为False，则b一定不是名人
所以每次调用know，都可以排除一个人，同时剩下一个候选人。再利用候选人和下一个人做比较，又可以排除一个人，剩下一个候选人，一共需要n-1次，排除掉n-1个人，再对剩下的候选人做全面的检查。

```python
def findCelebrity(n):
    res = 0
    for i in range(n):
        if know(res, i):
            res = i
    for i in range(res):
        if know(res, i) or (not know(i, res)):
            return -1
    for i range(res+1, n):
        if not know(i, res):
            return -1
    return res
```

## 160 相交链表

p1指向headA，p2指向headB，当p1/p2指向链表headA/headB的末尾时，指向headB/headA，向前走，直到相遇或者达到末尾。
相交时，能相遇，p1==p2：p1走过了A的单独部分+公共部分+B的单独部分，p2走过了B的单独部分+公共部分+A的单独部分，所以在相交能相遇
不相交时，能在末尾相遇，None==None

```python
def getIntersectionNode(headA, headB):
    p1, p2 = headA, headB
    while p1!=p2:
        if not p1:
            p1 = headB
        else:
            p1 = p1.next
        if not p2:
            p2 = headA
        else:
            p2 = p2.next
    if p1:
        return p1.val
    else:
        return None
```

## 279 完全平方数

解法一：动态规划

建立n+1的数组dp，表示完全平方数的最少组合个数，如果n是完全平方数，则dp[n]=1，否则，dp[n]=min(dp[j*j]+dp[i-j*j]),j属于[1, n开平方]
O(n^(3/2))

```python
def numSquares(n):
    if n<=0:
        return 0
    if int(n**0.5)**2==n:
        return 1
    dp = [0 for _ in range(n+1)]
    for i in range(int(n**0.5)):
        dp[i*i]=1
    for i in range(1, n):
        if dp[i]:
            continue
        count = n
        for j in range(1, int(i**0.5)):
            count = min(count, dp[j*j]+dp[i-j*j])
        dp[i] = count
    return dp[-1]
```

解法二：数学公式

Lagrange 四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。
满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定满足 n=4a(8b+7)
并且n/4的平方和个数与n相等，比如 20=2^2+4^2, 5=1^2+2^2

```python
class Solution:

    def isSquare(self, n: int) -> bool:
        sq = int(math.sqrt(n))
        return sq*sq == n

    def numSquares(self, n: int) -> int:
        # Lagrange's four-square theorem
        if self.isSquare(n):
            return 1
        while n % 4  == 0:
            n >>= 2
        if n%8 == 7:
            return 4
        sq = int(math.sqrt(n)) + 1
        for i in range(1,sq):
            if self.isSquare(n - i*i):
                return 2
        return 3
```

## 280. Wiggle Sort 摆动排序

https://www.cnblogs.com/grandyang/p/5177285.html

nums[0] <= nums[1] >= nums[2] <= nums[3]....
[3,5,1,6,2,4]

解法一：
数组排序，然后调换1，2的数字，3，4的数字，以此类推

解法二：
O(n):对于奇数位置，nums[i]>=nums[i-1]，对于偶数位置，有nums[i]<=nums[i-1]
因此对每个数字，如果不满足条件，和前面位置调换即可
以奇数位置为例，如果不满足条件，i-2>=i-1>i，调换之后为i-2>i < i-1，满足条件

```python
def wiggleSort(nums):
    if len(nums)<=1:
        return nums
    
    for i in range(1, len(nums)):
        if (i%2==1 and nums[i-1]>nums[i]) or (i%2==0 and nums[i-1]<nums[i]):
            nums[i-1], nums[i] = nums[i], nums[i-1]
```

## 281 锯齿迭代器  

https://github.com/grandyang/leetcode/issues/281

建立队列queue，将k个列表的头放入(index, vj, nj)（第vj个队列的第index元素），每次取出队首，并将对应列表的下一个元素放入队尾

```python
from collections import deque
class ZigzagIterator(object):
 
    def __init__(self, v1, v2):
        """
        Initialize your data structure here.
        :type v1: List[int]
        :type v2: List[int]
        """
        self.que = deque()
        self.que.extend([(0, 0), (0, 1)])
        self.v = [v1, v2]
    def next(self):
        index, j = self.que.popleft()
        res = self.v[j][index]
        if index+1<len(self.v[j]):
            self.que.append((index+1, j))
        return res

    def hasNext(self):
        return len(self.que)
```

## 282. 给表达式添加运算符

最简单的情况，对于 + -，并且只能一位数字，我们可以连续地进行计算，比如5+2-8，从左到右计算得到 5+2=7，7-8=-1

比较复杂的情况，+ - * ，只能一位数字，对于2+3* 4 * 5，2+3=5，2+3* 4 = 5-3+3* 4=14，2+3* 4* 5 = 14-12+12* 5= 62，所以需要pre记录如果当前数字前面用乘法，value = value-pre+pre* cur, pre = pre* cur

更复杂的情况，考虑+ - * ，可以多位数字，将多位数字也记为一种右移运算，即 cur = cur* 10+nums[index ]

此时，需要四个变量 pre, cur, index和value，value表示当前表达式的值，

最后，需要考虑第一个数字只能是加法，每个多位数字不能是0开头。

```python

def dfs(index, pre, cur, value):
    # 多位数字
    cur = cur*10+nums[index]
    # 移位运算
    dfs(index+1, pre, cur, value)
    # 加法运算
    dfs(index+1, cur, 0, value+cur)
    # 减法运算
    dfs(index+1, -cur, 0, value-cur)
    # 乘法运算
    dfs(index+1, pre*cur, 0, value-pre+pre* cur)




class Solution:
    def addOperators(self, num: str, target: int) -> List[str]:
        self.num = num
        self.target = target
        self.res = list()
        self.path = list()
        self.dfs(0, 0, 0, 0)
        return self.res

    def dfs(self, index, pre, cur, value):
        if index==len(self.num) and value==self.target and cur==0:
            self.res.append(''.join(self.path[1:]))
            return
        if index==len(self.num):
            return
        
        cur = cur*10+int(self.num[index])
        if cur>0:
            self.dfs(index+1, pre, cur, value)
        self.path.extend(['+', str(cur)])
        self.dfs(index+1, cur, 0, value+cur)
        if len(self.path)>2:
            self.path[-2] = '-'
            self.dfs(index+1, -cur, 0, value-cur)
            self.path[-2] = '*'
            self.dfs(index+1, pre*cur, 0, value-pre+pre*cur)
        self.path.pop()
        self.path.pop()
        return
```

## 284. 顶端迭代器

peek之后用cur记录取出来的元素，然后

```python
# Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = iterator
        self.cur = None

    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        if not self.cur:
            self.cur = self.iterator.next()
        return self.cur
        

    def next(self):
        """
        :rtype: int
        """
        if self.cur:
            res = self.cur
            self.cur = None
            return res
        else:
            res = self.iterator.next()
            return res
        

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.cur!=None or self.iterator.hasNext()
        

# Your PeekingIterator object will be instantiated and called as such:
# iter = PeekingIterator(Iterator(nums))
# while iter.hasNext():
#     val = iter.peek()   # Get the next element but not advance the iterator.
#     iter.next()         # Should return the same value as [val].
```

## 285 二叉搜索树中的顺序后继  

后继：有右子树，右子树的最左结点；没有右子树，找祖父结点（祖父结点是其父节点的左子树）的父节点。用栈记录父节点

```python
def inorderSuccessor(self, root, p):
    self.stack = [None]
    ret = self.get(root, p)


def get(self, root, p):
    self.stack.append(root)
    if root.val==p.val:
        return root
    if root.val>p.val:
        return self.get(root.left, p)
    if root.val<p.val:
        return self.get(root.right, p)


def getSuccessor(self, p):
    if p.right:
        root = p.right
        while root.left:
            root = root.left
        return root
    else:
        while self.stack[-2] and self.stack[-2].left!=self.stack[-1]:
            self.stack.pop()
        return self.stack[-2]
```

## 286 墙与门

-1 表示墙或是障碍物, 0是门，INF是房间

BFS：从门开始扩散

```python
def wallsAndGates(self, rooms):
    n, m = len(rooms), len(rooms[0])
    for i in range(n):
        for j in range(m):
            if rooms[i][j]==0:
                bfs(i, j, 0)


def bfs(i, j, value):
    if not inRooms(i, j):
        return
    if rooms[i][j]==-1:
        return
    if rooms[i][j]<value:
        return
    rooms[i][j]=value
    bfs(i+1, j, value+1)
    bfs(i-1, j, value+1)
    bfs(i, j+1, value+1)
    bfs(i, j-1, value+1)
    return

def inRooms(i, j):
    return -1<i<n and -1<j<m
```

## 287. 寻找重复数

https://leetcode-cn.com/problems/find-the-duplicate-number/comments/

nums = [1,3,4,2,2]

方法一：二分法

O(nlogn)
定义cnt表示nums数组中小于等于i的数的个数(1<=i<=n)，假设重复的数字是target，那么[1, target-1]中的数字满足cnt[i]<=i，[target, n]中的数字满足cnt[i]>i，并且cnt具有单调性。下面证明该性质：
对于nums只出现重复的数字，没有缺失的数字，性质明显成立，[1, target-1]:cnt[i]=i，[target, n]:cnt[i]=i+1
对于nums出现重复的数字target以及缺失数字j，可以理解成数字target代替j，如果j< target，那么[j, target]:cnt[i]均减1，其他不变，如果j>=target, [target, j-1]:cnt均加1，其他不变，也满足性质。
nums = [1,3,4,2,2]
cnt =  [1,3,4,5]

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)-1
        left, right = 1, n
        cnt = 0
        res = -1
        while left<=right:
            cnt = 0
            mid = (left+right)//2
            for val in nums:
                if val<=mid:
                    cnt+=1
            if cnt<=mid:
                left = mid+1
            else:
                res = mid
                right = mid-1
        return res
```

方法二：二进制法

将数字按照二进制展开，对于第i位，记nums数组中第i位的数一共有x个，数字[1, n]第i位的数一共有y个，如果重复的数字有该位，那么x>y。下面证明这个性质。
如果只有重复的数字，那么重复数字对应第i位的x=y+1，非对应位满足x=y
如果有重复的数字target和缺失的数字j，可以理解成target替代了这些数字，分情况讨论：target和j的第i位同为1，那么x=y+1；target第i位为1，j的第i位为0，那么x=y+2；target和j的第i位同为0，x=y；target第i位为0，j的第i位为1，那么x=y-1，所以重复数字target对应的位满足x>y，非对应位x<=y

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        bitmax = 0
        n = len(nums)-1
        while n>>bitmax:
            bitmax+=1
        res = 0
        for bit in range(bitmax):
            x, y = 0, 0
            for i in range(n+1):
                x += 1&nums[i]>>bit
                y += 1&i>>bit
            if x>y:
                res = res | 1<<bit
        return res
```

方法三：快慢指针

定义f(i)=nums[i ]即i-->nums[i ]，我们需要证明从0开始，一定可以得到一条有入口的环(2-3-4-3为有入口的环且入口为3，2-3-2为无入口的环)，并且环的入口为重复元素。

数组中的重复元素的充分必要条件是：nums[i ]==nums[j ], 且i!=j.

第一步：证明从0开始，一定可以得到一条有入口的环。
$0->x_0->f(x_0)->f^2(x_0)->...->f^n(x_0) == 0->x_0->x_1->...->x_n$，因为只有1~n的n个数字，所以{x_0,....,x_n}一定存在重复的元素，不妨假设x_i==x_j(i!=j)为第一个重复的元素，显然x_i不可能等于0，有$0->x_0->x_1->...->x_i->...->x_{j-1}-->x_i$

第二步：证明环的入口为所求的重复元素
对于环的入口x_i，有nums[x_{i-1 ]=x_i, nums[x_{j-1 }]=x_i，显然i!=j且x_{i-1}!=x_{j-1}，那么x_i即为所求的重复元素。

第三步：证明只有从0开始，才能得到一条有入口的环。
反证法：对于其他数字，都可以令nums[i]=i，得到无入口的环
0之所以特殊是因为数字是1~n，反之，如果数字是0~n-1，那么就应该从n开始，得到有入口的环。

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow, fast = nums[0], nums[nums[0]]
        while slow!=fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        slow = 0
        while slow!=fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
```

## 	288	单词的唯一缩写  

```python
from collections import defaultdict
class Solution():
    def __init__(self, dictionary):
        self.word = defaultdict(list)
        for word in dictionary:
            s = self.get_key(word)
            self.word[s].append(word)
    

    def get_key(self, word):
        res = word[0]+str(len(word))+word[-1]
        return res
    
    def isUnique(self, word):
        s = self.get_key(word)
        return not self.word[s] or (word in self.word[s] and len(self.word[s])==1)
```

## 289. 生命游戏

方法：双bit位
要求只能原地改变数组元素，O(1)的空间复杂度
所以使用双bit位表示数组的原值和更新后的值

```python
class Solution:
    def gameOfLife(self, board: List[List[int]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        n, m = len(board), len(board[0])
        def get_neighbors(i, j):
            dx = [-1, 0, 1, -1, 1, -1, 0, 1]
            dy = [-1, -1, -1, 0, 0, 1, 1, 1]
            res = 0
            for k in range(8):
                x = i+dx[k]
                y = j+dy[k]
                if (-1<x<n) and (-1<y<m) and (board[x][y]&1==1):
                    res+=1
            return res
        for i in range(n):
            for j in range(m):
                live_neighbors = get_neighbors(i, j)
                if board[i][j]==1 and (2<=live_neighbors<=3):
                    board[i][j] = board[i][j]|2
                elif board[i][j]==0 and (live_neighbors==3):
                    board[i][j] = board[i][j]|2
        for i in range(n):
            for j in range(m):
                board[i][j] = board[i][j]>>1
```

## 290. 单词规律

False: 同一个字母对应的单词不一样或者同一个单词对应的字母不一样

方法一：建立pattern到str的映射和str到pattern的映射, map1, map2

方法二：建立pattern到123的映射和str到123的映射，判断映射后的字符串是否相等/或者一边映射一边判断是否相等

abba-->1221
dog cat cat dog-->1221

```python
class Solution:
    def wordPattern(self, pattern: str, str: str) -> bool:
        strs = str.split()
        map1 = dict()
        map2 = dict()
        if len(strs)!=len(pattern):  
            return False
        n = len(strs)
        for i in range(n):
            if map1.get(pattern[i], -1)!=map2.get(strs[i], -1):
                return False
            map1[pattern[i]] = i
            map2[strs[i]] = i

        return True
```

## 291. 单词规律II

https://www.cnblogs.com/lightwindy/p/9736251.html

```python
class Solution():
    def wordPatternMatch(self, pattern, words):
        p2w = dict()
        w2p = dict()
        return self.wordPatternMatch2(pattern, words, 0, 0, p2w, w2p)

    def wordPatternMatch2(self, pattern, words, i, j, p2w, w2p):
        if i==len(pattern) and j==len(words):
            return True
        if i==len(pattern) or j==len(words):
            return False
        p = pattern[i]
        if p in p2w:
            w = p2w[p]
            if w!=words[j:j+len(w)]:
                return False
            return self.wordPatternMatch2(pattern, words, i+1, j+len(w), p2w, w2p)
        else:
            for k in range(j, len(words)):
                w = words[j:k+1]
                if w in w2p:
                    continue
                p2w[p], w2p[w] = w, p
                if self.wordPatternMatch2(pattern, words, i+1, k+1, p2w, w2p):
                    return True
                p2w.pop(p)
                w2p.pop(w)
        return False
```

## 	294	翻转游戏 II  

方法一：尝试所有的可能
时间复杂度：O(n^{n/2})

```python
def run(string s):
    # 先手存在赢的策略，返回True，否则返回False
    n = len(s)
    for i in range(n-1):
        if s[i:i+2]=="+" and (not run(s[:i]+"--"+s[i+2:])):
            return True
    return False
```

方法二：Nim游戏

https://zhuanlan.zhihu.com/p/52931007

组合游戏ICG：

1. 两个玩家公平地构成
2. 游戏有一个状态集合，表示游戏过程中的所有可能状态，通常是有穷的
3. 游戏的规则描述了在某个状态下玩家移动到下一个状态的合法移动，如果该规则对两个玩家是相同的，就是impartial，否则就是partizan的
4. 玩家交替移动
5. 当玩家移动到某一个状态，下一个玩家没有可行地移动时，游戏结束
6. 在通常的规则下，最后一个玩家获胜
7. 求先手必胜策略

对于一个游戏状态，定义

1. P-position：在该状态下，上一个玩家能够获胜，或者说当前玩家必败，即先手必败
2. N-position：在该状态下，下一个玩家能够获胜，或者说当前玩家必胜，即先手必胜

对于游戏状态P，N，有以下三条性质：

1. 终止状态(上一个玩家移动之后的状态，下一个玩家没有可行的移动，宣布失败终止)是先手必败 P-position
2. 对于每一个 P-position, 任意一个合法的移动后的状态是 N-position，即假设移动后有三种状态，则 P-->(N, N, N)
3. 对于每一个 N-position，存在一个合法的移动后的状态是 P-position，即假设移动后有三种状态，则 N-->(N, P, N)

Nim游戏：

1. 假设有m堆碎片，分别是 x1, x2, ... xm
2. 两个玩家轮流取碎片，每次必须从其中的一堆至少取一个碎片，至多不超过选择的堆
3. 最后一个取碎片的玩家获胜

Nim-Sum：

(x1, x2, ... xm)是一个P-pos当且仅当x1^ x2^ ...^ xm=0

更一般地，我们引入 Graph Games.

Graph Games：将游戏转换为一个有向图G(X, F)，其中 X 表示游戏中所有状态的集合，F表示状态之间的移动关系。如果对于节点x，F(x)是空集，那么x就是一个终止节点

SG-函数：定义图G(X, F)的SG-函数为$g(x)=min{n>=0: n!=g(y) for,y\in F(x)}=mex{g(y): y\in F(x)}$，即在非负整数集合中的第一个非负整数。注意 g(x) 是递归定义的，对终止节点x，g(x)=0.

SG-函数 g(x) 有如下性质：

1. x是终止节点，则g(x)=0
2. g(x)=0，那么x的每个后续节点y, g(y)!=0, 
3. g(x)!=0,那么存在x的一个后继节点y，g(y)=0

> g(x)=0，对应的状态x是P-pos(先手必败)
  g(x)!=0，对应的状态是N-pos(先手必胜)

Sums of Combinatorial Games：即几个组合游戏合并一个大游戏

1. 玩家的移动变成：选择其中一个未终止的游戏，进行一次合法的移动
2. 终止状态为：所有游戏都终止了

The Sprague-Grundy Theorem： 对Sums of Combinatorial Games，我们同样可以求出状态x=(x1, x2,...xn)的SG-函数

1. g(x) = g(x1)^ g(x2)^ ...^ g(xn)

举例说明怎么使用SG函数。

例子1：取石子问题，有1堆n个的石子，每次只能取1，3，4个石子，先取完者胜利，那么各个数的SG值是多少。

x=0, sg[0]=0
x=1, 可以取走一个石子，sg[1] = mex{sg[0]}=mex{0}=1
x=2, 可以取走一个石子，sg[2] = mex{sg[1]}=mex{1}=0
x=3，可以取走{1，3}个石子，sg[3]=mex{sg[2], sg[0]}=mex{0, 0}=1
x=4，可以取走{1,3,4}个石子，sg[4]=mex{sg[3], sg[1], sg[0]}=mex{1,1,0}=2

以此类推:
x::::0, 1, 2, 3, 4, 5, 6, 
sg:: 0, 1, 0, 1, 2, 3, 2,
P/N: P, N, P, N, N, N, N
P是先手必败， N是先手必胜

例子2：假设有n堆碎片，分别是 x1, x2, ... xn，两个玩家轮流取碎片，每次必须从其中的一堆至少取一个碎片，至多不超过选择的堆，最后一个取碎片的玩家获胜

我们可以看成是多个组合游戏的合并，对于其中一个组合游戏，即一堆碎片x，有
x=0, g[0]=0
x=1, g[1]=mex{g[0]}=mex{0}=1
x=2, g[2]=mex{g[0], g[1]}=mex{0, 1}=2
...
x, g[x]=mex{g[0], g[1], ..., g[x-1]}=x
所以对于一个组合游戏有g[x]=x
所以对于多个组合游戏有g[x]=g[x1]^ ... ^ g[xn]=x1^ ... xn

例子3：翻转游戏 II ：输入x中可能带有-，令x=(x1, x2, ..., xn)，其中xi表示连续的+，且xi和x(i+1)中间只有负号，是n个组合游戏(输入只有连续的+)的合并，所以g(x)=g(x1)^ ... g(xn)

对于单个组合游戏，有：
x=0, g[0]=0
x=1, g[1]=0
x=2, g[2]=mex{g[0]}=mex{0}=1
x=3, g[3]=mex{g[1]}=mex{0}=1
x=4, g[4]=mex{g[1]^ g[1], g[0]^ g[2]}=mex{0^ 0, 0^ 1}=2
...
x, g[x]=mex{g[0]^ g[x-2], g[1]^ g[x-3], ... g[x-2]^ g[0]}

```python
# https://zhuanlan.zhihu.com/p/30721019
def canWin(s):
    s = list(filter(None, s.split("-")))
    s = [len(val) for val in s]
    n = max(s)
    g = [0 for _ in range(n+1)]
    for i in range(2, n+1):
        mex = [False for _ in range(n+1)] # 用于记录mex集合
        for j in range(0, i-1):
            mex[g[j]^g[i-j-2]]=True
        for j in range(i):
            if not mex[j]:
                g[i]=j
                break
    res = 0
    for val in s:
        res = res^g[val]
    return res!=0
```

## 数组中未出现的最小正整数

https://www.cnblogs.com/stemon/p/4633854.html

```python
# 开辟新的数组
def demo(nums):
    new_nums = [0 for _ in range(len(nums))]
    for val in nums:
        new_nums[val-1]=val
    res = len(nums)
    for i, val in enumerate(new_nums):
        if val==0:
            res = i+1
            break
    return res

# 原地修改
def demo(nums):
    n = len(nums)
    i = 0
    while i<n:
        val = nums[i]
        if 0< val< n+1 and i+1!=val and nums[val-1]!=val:
            nums[i], nums[val-1] = nums[val-1], nums[i]
        else:
            i = i+1
    res = len(nums)
    for i, val in enumerate(nums):
        if val!=i+1:
            res = i+1
            break
    return res
```

## 295. 数据流的中位数

方法一：大顶堆和小顶堆 O(lgn)

```python
import heapq
class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.count = 0
        self.max_h = []
        self.min_h = []

    def addNum(self, num: int) -> None:
        self.count+=1
        if self.count%2:
            heapq.heappush(self.min_h, num)
            num = heapq.heappop(self.min_h)
            heapq.heappush(self.max_h, (-num, num))
        else:
            heapq.heappush(self.max_h, (-num, num))
            _, num = heapq.heappop(self.max_h)
            heapq.heappush(self.min_h, num)
        return 

    def findMedian(self) -> float:
        if self.count%2:
            return self.max_h[0][1]
        else:
            return (self.max_h[0][1]+self.min_h[0])/2
```

方法二：平衡二叉搜索树 O(lg n)

https://leetcode-cn.com/problems/find-median-from-data-stream/solution/shu-ju-liu-de-zhong-wei-shu-by-leetcode/

平衡二叉搜索树的插入和删除的复杂度是 O(lg n)，且是有序的。

```python
class MedianFinder {
    multiset<int> data;
    multiset<int>::iterator mid;

public:
    MedianFinder()
        : mid(data.end())
    {
    }

    void addNum(int num)
    {
        const int n = data.size();
        data.insert(num);

        if (!n)                                 // first element inserted
            mid = data.begin();
        else if (num < *mid)                    // median is decreased
            mid = (n & 1 ? mid : prev(mid));
        else                                    // median is increased
            mid = (n & 1 ? next(mid) : mid);
    }

    double findMedian()
    {
        const int n = data.size();
        return (*mid + *next(mid, n % 2 - 1)) * 0.5;
    }
};
```

## 296 最佳的碰头地点

在一维情况下，最佳碰头地点是中位数mid

如果是奇数个人，那么最佳地点往左挪一点，mid左边的人的距离减一，本身及右边的人距离加一，总体距离加一
如果是偶数个人，那么最佳地点其实是n//2~n//2+1中的任意一个地点都行，如果最佳地点往n//2左边挪一点，左边人距离减1，右边距离加1，总体距离加2，反之亦然。

```python
class Solution {
public:
	int minTotalDistance(vector<vector<int>>& grid) {
		vector<int> vx;
		vector<int> vy;
		for (int x = 0; x < grid.size(); x++) {
			for (int y = 0; y < grid[x].size(); y++) {
				if (grid[x][y] > 0) {
					vx.push_back(x);
					vy.push_back(y);
				}
			}
		}
		sort(vy.begin(), vy.end());
		int mx = vx[vx.size() / 2];
		int my = vy[vy.size() / 2];

		int ans = 0;
		for (int x : vx) ans += abs(x - mx);
		for (int y : vy) ans += abs(y - my);
		return ans;
	}
};

```

## 297. 二叉树的序列化与反序列化

先序遍历

```java
public class Codec {
    public String rserialize(TreeNode root, String str) {
        if (root == null) {
            str += "None,";
        } else {
            str += str.valueOf(root.val) + ",";
            str = rserialize(root.left, str);
            str = rserialize(root.right, str);
        }
        return str;
    }
  
    public String serialize(TreeNode root) {
        return rserialize(root, "");
    }
  
    public TreeNode rdeserialize(List<String> l) {
        if (l.get(0).equals("None")) {
            l.remove(0);
            return null;
        }
  
        TreeNode root = new TreeNode(Integer.valueOf(l.get(0)));
        l.remove(0);
        root.left = rdeserialize(l);
        root.right = rdeserialize(l);
    
        return root;
    }
  
    public TreeNode deserialize(String data) {
        String[] data_array = data.split(",");
        List<String> data_list = new LinkedList<String>(Arrays.asList(data_array));
        return rdeserialize(data_list);
    }
}

```

## 300 最长上升非连续子序列 

单调栈h[j] 记录长度是j+1的最长递增子序列的末尾数字 h[j]: 递增序列, h[j] 初始化为无穷大
pos: h[pos-1]< arr[i] <= h[pos] 即第一个大于等于arr[i]的位置
dp[i]: arr[i] 对应的最长递增子序列的长度

```python
def upper_bound(h, k):
    if not h:
        return 0
    l, r = 0, len(h)-1
    res = len(h)
    # print(h, k)
    while l<=r:
        mid = (l+r)//2
        # print(mid)
        if h[mid]>k:
            res = mid
            r = mid-1
        elif h[mid]==k:
            return mid
        else:
            l = mid+1
    return res

def get_list(dp, arr, max_len):
    res = [0]*max_len
    for i in range(len(arr)-1, -1, -1):
        if max_len==0:
            break
        if dp[i]==max_len-1:
            res[max_len-1]=arr[i]
            max_len-=1
    return res
import bisect
def demo1(n, arr):
    h = list()
    dp = [0]*len(arr)
    for i in range(n):
        # pos = upper_bound(h, arr[i])
        pos = bisect.bisect_left(h, arr[i])
        if pos>=len(h):
            h.append(arr[i])
        else:
            h[pos] = arr[i]
        dp[i] = pos
    res = get_list(dp, arr, len(h))
    return res

if __name__=='__main__':
    n = int(input())
    arr = list(map(int, input().split()))
    res = demo1(n, arr)
    res_str = ' '.join(list(map(str, res)))
    print(res_str)
```

即对于元素 arr[i]，找到合适的位置 pos，满足 h[pos]>=arr[i]，做替换或者增加，此时，h是单调的且满足长度是j+1的最长递增子序列的末尾数字是h[j]，dp表示元素 arr[i] 对应的最长递增子序列的最长长度

例如：2 1 5 3 6 4 8 9 7
h[j]:
2
1
1 5
1 3
1 3 6
1 3 4
1 3 4 8
1 3 4 8 9
1 3 4 7 9
长度为1的最长递增子序列的末尾是1
长度为2的最长递增子序列的末尾是3
长度为3的最长递增子序列的末尾是4
长度为4的最长递增子序列的末尾是7
长度为5的最长递增子序列的末尾是9

这里没有直接弹出而是采取替换的原因是 当arr[i]大于最后一个元素时，最长长度应该增加，如果弹出的话，就没法体现增加的性质

对于 2 3 1 4
h:
2
2 3
1 3
1 3 4
这里的3会对4产生影响，应该保留

其他解法：

1. 排序，求公共子序列 O(n_2)
2. h[j] = max(h[i])+1, arr[i]<=arr[j] O(n_2)

## 301. 删除无效的括号

BFS：每次尝试删除一个括号，因为最长的合法括号的长度都是一样的，时间 O(n^m) n表示输入长度，m表示无效括号数量，空间n^m

```python
class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        def is_valid(string):
            cnt = 0
            for s in string:
                if s=="(":
                    cnt+=1
                elif s==")":
                    cnt-=1
                if cnt<0:
                    return False
            return cnt==0
        que = {s}
        while que:
            que = list(filter(is_valid, que))
            print(que)
            if que:
                return que
            que = set([ val[:i]+val[i+1:] for val in que for i in range(len(val)) if val[i] in "()"])
        return [""]
```

## 302 包含全部黑色像素的最小矩形

An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.

For example, given the following image:

[
  "0010",
  "0110",
  "0100"
]
and x = 0, y = 2,

Return 6.

黑色像素一定相邻

方法一：暴力搜索
找到最左、最右、最上、最下边界

```java
class Solution {
public:
    int minArea(vector<vector<char>>& image, int x, int y) {
        int left = y, right = y, up = x, down = x;
        for (int i = 0; i < image.size(); ++i) {
            for (int j = 0; j < image[i].size(); ++j) {
                if (image[i][j] == '1') {
                    left = min(left, j);
                    right = max(right, j);
                    up = min(up, i);
                    down = max(down, i);
                }
            }
        }
        return (right - left + 1) * (down - up + 1);
    }
};
```

方法二：二分搜索
最左边界一定在y的左边，二分搜索y的左边，如果左边某一列有1，那么该列就可能是左边界

我们再来看一种优化了时间复杂度的解法，这是一种二分搜索法，以给定的一个黑像素(x, y)为中心，分别用二分法快速找到整个黑色区域的上下左右的临界点，然后直接算出面积。首先我们来看上边界怎么找，既然是以(x, y)为中心，而且上边界又是某个行数，那么其范围肯定在[0, x]之间，能成为上边界的条件是该行中至少有一个点是1，那么其列数的范围就在[0, n]之间，我们在进行二分搜索的时候，先根据i, j算出中间行mid，然后列数从0开始遍历，直到找到为1的点，或者越界位置，然后我们判断列数是否越界，越界的话，说明当前行没有1，此时更新i为mid+1，如果找到了1，那么更新j为mid。找下边界也是同样的道理，但是跟上边界稍微又些不同的地方是，如果当前行找到了1，我们应该再往下找，那么i应该更新为mid+1；如果没找到，就应该往上找，靠近(x, y)点；所以两种情况只是在二分法更新范围的地方正好想法，所以我们可以用一个bool型的变量opt来决定还如何更新行数。

二分搜索更新：在找上下边界时，是image[mid][k]，左右边界时，是image[k][mid]，用h表示是上下边界还是左右边界
在找上、左边界时，如果没有找到1且posi为真，则i=mid+1；下、右边界时，如果找到1，且posi为假，则i=mid+1，用posi表示上、左还是下、右

```python
def minArea(image, x, y):
    n, m = len(image), len(image[0])
    
    def binary_search(ho, i, j, low, high, ):
        res = 0
        while i<=j:
            mid = (i+j)//2
            k = low
            while k<high and ((h and image[mid][k]=="0") or ((not h) and image[k][mid]=="0")):
                k = k+1
            if k<high ^ posi:
                res = mid
                i = mid+1
            else:
                j = mid-1
        return res         

    up = binary_search(True, 0, x, 0, m, True))
    down = binary_search(True, x, n-1, 0, m, False))
    left = binary_search(False, 0, y, 0, n, True))
    right = binary_search(False, y, m-1, 0, n, False))

    return (down-up+1)*(right-left+1)
```

## 305 岛屿数量 II

并查集

```python
class Union():
    def __init__(self, m, n):
        self.parent = [[(-1, -1) for _ in range(n)] for _ in range(m)]
        self.rank = [[0 for _ in range(n)] for _ in range(m)]
    
    def find(self, node):
        x, y = node
        if self.parent[x][y]!=(x, y):
            self.parent[x][y] = self.find(self.parent[x][y])
        return self.parent[x][y]
    
    def merge(self, node1, node2):
        x1, y1 = self.find(node1)
        x2, y2 = self.find(node2)
        if (x1, y1)==(x2, y2):
            return False
        if self.rank[x1][y1]==self.rank[x2][y2]:
            self.parent[x2][y2] = (x1, y1)
            self.rank[x1][y1] += 1
        elif self.rank[x1][y1]<self.rank[x2][y2]:
            self.parent[x2][y2] = (x1, y1)
        else:
            self.parent[x1][y1] = (x2, y2)
        return True
```

```python
class Solution():
    def numIslands2(self, m, n, positions):
        nn = m*n
        uni = Union(m, n)
        dirs = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        res = list()
        cnt = 0
        def in_area(x, y):
            return -1<x<m and -1<y<n

        def merge_dirs(x, y):
            res = 0
            for dx, dy in dirs:
                new_x, new_y = x+dx, y+dy
                if in_area(new_x, new_y) and uni.parent[new_x][new_y]!=(-1, -1) and uni.merge((x, y), (new_x, new_y)):
                    res+=1
            return res
        for x, y in positions:
            print(x, y)
            print(uni.parent)
            cnt+=1
            if uni.parent[x][y]!=(-1, -1):
                res.append(cnt)
                continue
            uni.parent[x][y] = (x, y)
            cnt-=merge_dirs(x, y)
            res.append(cnt)
        return res
```

## 306 累加数

dfs(i, j, k): i, j, k分别是三个数的开始位置，自然可以确定三个数的结束位置。

```python
class Solution:
    def isAdditiveNumber(self, num: str) -> bool:
        n = len(num)
        i = 0
        for j in range(i+1, n):
            for k in range(j+1, n ):
                if self.dfs(num, i, j, k):
                    return True
        return False

    def dfs(self, num, i, j, k):
        n = len(num)
        if j-i>1 and num[i]=="0":
            return False
        if k-j>1 and num[j]=="0":
            return False
        if k==n:
            return True
        sum_ij = str(int(num[i:j])+int(num[j:k]))
        dk = len(sum_ij)
        if k+dk<=n and num[k:k+dk]==sum_ij:
            return self.dfs(num, j, k, k+dk)
        return False
```

## 最短距离 Dijkstra 算法

Dijkstra算法：

1. 在未访问点集合中找出最短点
2. 根据最短点更新未访问点集合中的其他点
3. 最后记录的是源点s到其他点的权重

O(E log V)

```python
import heapq
import sys
class Solution():
    def maxProbability(self, n: int, edges, succProb, start: int, end: int) -> float:
        e = [[] for _ in range(n)] # 邻接表
        visited = [0 for _ in range(n)] # 记录已访问点和未访问点
        dis = [sys.maxsize for _ in range(n)] # 记录每个点的权重

        for (node1, node2), p in zip(edges, succProb):
            e[node1].append((node2, p))
            e[node2].append((node1, p))
        
        q = [(1.0, start)]
        heapq.heapify(q)
        dis[start] = 1.0
        while q:
            p, node = heapq.heappop(q)
            if visited[node]:
                continue
            visited[node] = 1
            for next_node, next_e_p in e[node]:
                if not visited[next_node]:
                    dis[next_node] = min(dis[next_node], dis[node]+next_e_p)
                    heapq.heappush(q, (dis[next_node], next_node))
        return dis[end]
```

## 1515. 服务中心的最佳位置

数学证明过程：https://leetcode-cn.com/problems/best-position-for-a-service-centre/solution/shu-xue-zheng-ming-by-acw_wangdh15/

距离是个凸函数

方法一：三分法

[l, r]=>[l, m1, m2, r]:
f(m1)< f(m2)：则最优值一定不在(m2, r]，令r=m2
f(m1)> f(m1): 则最优值一定不在[l, m1)，令l=m1

```python
# 写法一
class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        eps = 10**(-6)
        def dis(mx, my):
            return sum([((mx-x)**2+(my-y)**2)**0.5 for x, y in positions])

        def cal_my(mx):
            l, r = 0, 100
            while r-l>eps:
                m1 = l+(r-l)/3
                m2 = l+2*(r-l)/3
                if dis(mx, m1)<dis(mx, m2):
                    r = m2
                else:
                    l = m1
            res = (l+r)/2
            return res

        def cal_mx():
            l, r = 0, 100
            while r-l>eps:
                m1 = l+(r-l)/3
                m2 = l+2*(r-l)/3
                y1 = cal_my(m1)
                y2 = cal_my(m2)
                if dis(m1, y1)<dis(m2, y2):
                    r = m2
                else:
                    l = m1
            mx = (l+r)/2
            my = cal_my(mx)
            # print(mx, my)
            return dis(mx, my)
        return cal_mx()

# 写法二
class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        def dis(mx, my):
            return sum([((mx-x)**2+(my-y)**2)**0.5 for x, y in positions])

        def three_divide(l=0, r=100, f=None, eps=10**(-6)):
            l, r = 0, 100
            while r-l>eps:
                m1 = l+(r-l)/3
                m2 = l+2*(r-l)/3
                if f(m1) < f(m2):
                    r = m2
                else:
                    l = m1
            res = (l+r)/2
            return res
        
        def xf(x):
            def yf(y):
                return dis(x, y)
            my = three_divide(f=yf)
            return dis(x, my)

        mx = three_divide(f=xf)
        my = three_divide(f=lambda y:dis(mx, y))
        return dis(mx, my)

# 写法二扩展
class Solution:
    def getMinDistSum(self, positions: List[List[int]]) -> float:
        def dis(mx, my, mz):
            pass

        def three_divide(l=0, r=100, f=None, eps=10**(-6)):
            pass

        def xf(x):
            def yf(y):
                def zf(z):
                    return dis(x, y, z)
                global mz
                mz = three_divide(f=zf)
                return dis(x, y, mz)
            my = three_divide(f=yf)
            return dis(x, my, mz)

        mx = three_divide(f=xf)
        my = three_divide(f=lambda y:dis(mx, y))
        return dis(mx, my)
```

## 树状数组、线段树、开根号分块

树状数组：求前缀和，好写，且时间复杂度的系数低，空间小 n
线段树：求区间和，更全面，空间 4n：树状数组能写的线段树都能写，但线段树能写的树状数组不一定能写
开根号分块全能
多维情况时 树状数组更好用

操作分为：单点修改+区间查询，区间修改+单点查询，区间修改+区间查询

### 树状数组

参考链接： 

https://blog.csdn.net/bestsort/article/details/80796531

修改和查询的复杂度是O(lgn)
原数组A和辅助数组C都是从1开始计数

首先理清几个公式：

对于C[i]，i的最左边有几个0，就在第几层

C[1] = A[1]
C[2] = A[1]+A[2]
C[3] = A[3]
C[4] = A[1]+A[2]+A[3]+A[4]
C[i] = A[i-2^k+1]+A[i-2^k+2]...+A[i] 其中k表示i的二进制从低位向高位数，第一个1所在的位置，2^k=i&-i

C[i] 的父节点是 C[j]:j=i+i&-i
证明：C[j]=A[j-2^(k_j)+1]+...+A[j], C[i]=A[i-2^(k_i)+1]+...+A[i]，j=i+i&-i，显然j>i，其次证明j-2^(k_j)+1< i-2^(k_i)+1，j-2^(k_j)+1- (i-2^(k_i)+1)=i&-i+2^(k_i)-2^(k_j)=2^(k_i+1)-2^(k_j)，不妨假设i=010或者110，则i&-i=010，j=100或者1000，显然j是i&-i至少左移一位，2^(k_j)>=2^(k_i+1)，所以j-2^(k_j)+1<= i-2^(k_i)+1，所以C[i] 的父节点是 C[j]:j=i+i&-i

C[j] 的子节点是 C[i]: i={j-2^0, j-2^1, j-2^2, ...j-2^(k_j-1)}
证明：不妨假设j=1000, 则 i={0111, 0110, 0100,}则i=j-1=0111,i+i&-i=1000, i=j-2=0110, i+i&~i=1000, ..., 得证

sum[i]=C[i]+sum[i-i&(-i)]，其中C[0]=0
证明: sum[i]=A[1]+...+A[i]=A[1]+...+A[i-i&(-i)]+A[i-i&(-i)+1]+...+A[i]=A[1]+...+A[i-i&(-i)]+C[i]=sum[i-i&(-i)]+C[i]
所以sum[i]=C[i]+sum[i-i&(-i)]

综上所述：
1. C[i] = sum( A[i-2^k+1, ..., i]  )
2. sum[i] = C[i] + sum[i-2^k ]

```python
class Solution():
    def __init__(self, arr):
        # 假设A和C都是从1开始计数
        self.A = arr
        self.n = len(arr)
        self.C = [0 for _ in range(n)]
        self.build(arr)

    def lowbit(self, x):
        return x&(-x)
    
    def build(self, arr):
        # 初始化
        for i in range(1, self.n):
            self.update(i, arr[i])
        return 

    # 1. 单点更新，区间查询
    def update(self, i, x):
        # 单点更新，从叶子节点到根节点，同时可以用于初始化
        # self.arr[i] += x
        while i<self.n:
            self.C[i]+=x
            i = i+lowbit(i)
        return 
    
    def getsum(self, i):
        # 区间查询：arr[1,2...i]
        res = 0
        while i>0:
            res+=self.C[i]
            i=i-lowbit(i)
        return res
    def getRangeSum(self, left, right):
        # [left, right]
        return self.getsum(right) - self.getsum(left-1)
    # 2. 区间修改，单点查询
    # 差分：令B[i]=A[i]-A[i-1]，A[0]=0，初始化略微不同，C[i]表示B[i]的前缀和
    # 单点查询A[i]等价于sum[B[1, ..., i]]前缀和，即区间查询
    # 区间修改A[l, ..., r]+=val, 等价于 C[l]+=val, C[r+1]-=val，即单点修改
    def build2(self, arr):
        # 初始化略微不同
        for i in range(1, self.n):
            self.update(i, arr[i]-arr[i-1])

    def update2_(self, i, x):
        # 单点更新，从叶子节点到根节点，同时可以用于初始化
        # self.arr[i] += x
        while i<self.n:
            self.C[i]+=x
            i = i+lowbit(i)
        return 

    def update2(self, l, r, x):
        # 区间修改：A[l, ..., r]+=x, 根据定义C[i]=A[i]-A[i-1]，等价于 C[l]+=val, C[r+1]-=val，即单点修改
        self.update(l, x)
        if r+1<self.n:
            self.update2_(r+1, -x)
    
    def getsum2(self, i):
        # 单点查询 A[i]=sum(B[1, ...,i])
        res = 0
        while i>0:
            res+=self.C[i]
            i=i-lowbit(i)
        return res
    
    # 3. 区间修改，区间查询
    # 公式推导见链接 https://blog.csdn.net/bestsort/article/details/80796531
    # B1[i] = A[i]-A[i-1], B2[i]=B1[i]*i, C1[i]是B1[i]的前缀和, C2[i] = B2[i]的前缀和
    # sum[p] = (p+1)*sum[B1[1...p]]-sum[B2[1,...i]]
    def build3(self, arr):
        for i in range(self.n):
            self.update3(i, arr[i])

    def update3_(self, i, x):
        # 单点更新，从叶子节点到根节点，同时可以用于初始化
        # self.B[i] += x
        while i<self.n:
            self.C1[i]+=x
            self.C2[i]+=i*x
            i = i+lowbit(i)
        return
    
    def update3(self, l, r, x):
        # 区间更新，arr[l, ..., r]+=x
        # B[i] = A[i]-A[i-1]，所以B[l]+=x, B[r+1]-=x
        self.update3_(l, x)
        if r+1<self.n:
            self.update3_(r+1, x)
    
    def getsum3(self, i):
        # 区间查询: arr[1,2,...x]
        res=0
        p=i
        while i>0:
            res+=(p+1)*self.C1[i]-self.C2[i]
        return res

    def getsum(self, i):
        # 区间查询：arr[1,2...x]
        res = 0
        while i>0:
            res+=self.C[i]
            i=i-lowbit(i)
        return res
```

总结为：区间修改用差分，单点修改用真值；修改用加(i&-i)，查询用减(i&-i)

有关二维矩阵的树状数组的使用类似

https://blog.csdn.net/bestsort/article/details/80796531

```python
# 单点修改+区间查询
void add(int x, int y, int z){ //将点(x, y)加上z
    int memo_y = y;
    while(x <= n){
        y = memo_y;
        while(y <= n)
            tree[x][y] += z, y += y & -y;
        x += x & -x;
    }
}
void ask(int x, int y){//求左上角为(1,1)右下角为(x,y) 的矩阵和
    int res = 0, memo_y = y;
    while(x){
        y = memo_y;
        while(y)
            res += tree[x][y], y -= y & -y;
        x -= x & -x;
    }
}
``` 

```python
# 区间修改，单点查询
void add(int x, int y, int z){ 
    for(int i = x; i; i += i & -i)
        for(int j = y; j; j += j & -j)
            tree[x][y] += z
}
void range_add(int xa, int ya, int xb, int yb, int z){
    add(xa, ya, z);
    add(xa, yb + 1, -z);
    add(xb + 1, ya, -z);
    add(xb + 1, yb + 1, z);
}
void ask(int x, int y){
    int res = 0;
    for(int i = x; i; i -= i & -i)
        for(int j = y; j; j -= j & -j)
            res += tree[x][y]
}
```

```python
# 区间修改，区间查询
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll;
ll read(){
    char c; bool op = 0;
    while((c = getchar()) < '0' || c > '9')
        if(c == '-') op = 1;
    ll res = c - '0';
    while((c = getchar()) >= '0' && c <= '9')
        res = res * 10 + c - '0';
    return op ? -res : res;
}
const int N = 205;
ll n, m, Q;
ll t1[N][N], t2[N][N], t3[N][N], t4[N][N];
void add(ll x, ll y, ll z){
    for(int X = x; X <= n; X += X & -X)
        for(int Y = y; Y <= m; Y += Y & -Y){
            t1[X][Y] += z;
            t2[X][Y] += z * x;
            t3[X][Y] += z * y;
            t4[X][Y] += z * x * y;
        }
}
void range_add(ll xa, ll ya, ll xb, ll yb, ll z){ //(xa, ya) 到 (xb, yb) 的矩形
    add(xa, ya, z);
    add(xa, yb + 1, -z);
    add(xb + 1, ya, -z);
    add(xb + 1, yb + 1, z);
}
ll ask(ll x, ll y){
    ll res = 0;
    for(int i = x; i; i -= i & -i)
        for(int j = y; j; j -= j & -j)
            res += (x + 1) * (y + 1) * t1[i][j]
                - (y + 1) * t2[i][j]
                - (x + 1) * t3[i][j]
                + t4[i][j];
    return res;
}
ll range_ask(ll xa, ll ya, ll xb, ll yb){
    return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1);
}
int main(){
    n = read(), m = read(), Q = read();
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            ll z = read();
            range_add(i, j, i, j, z);
        }
    }
    while(Q--){
        ll ya = read(), xa = read(), yb = read(), xb = read(), z = read(), a = read();
        if(range_ask(xa, ya, xb, yb) < z * (xb - xa + 1) * (yb - ya + 1))
            range_add(xa, ya, xb, yb, a);
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++)
            printf("%lld ", range_ask(i, j, i, j));
        putchar('\n');
    }
    return 0;
}
```


### 线段树

线段树的升级：zkw线段树 https://blog.csdn.net/bestsort/article/details/80796531

将[1,n]分解成若干特定的子区间(数量不超过4*n)

用线段树对“编号连续”的一些点，进行修改或者统计操作，修改和统计的复杂度都是O(log2(n))

用线段树统计的东西，必须符合区间加法，（也就是说，如果已知左右两子树的全部信息，比如要能够推出父节点）；否则，不可能通过分成的子区间来得到[L,R]的统计结果。

一个问题，只要能化成对一些“连续点”的修改和统计问题，基本就可以用线段树来解决了

区间求和，求最大，求最小

arr[1,2,...n]，开辟4*n空间的数组

参考链接：

https://www.cnblogs.com/jason2003/p/9676729.html
https://www.cnblogs.com/iris001999/articles/9058603.html
https://www.cnblogs.com/xenny/p/9801703.html
https://www.cnblogs.com/AC-King/p/7789013.html

备注：


```python
# 线段树
# 备注：树的节点从1开始计数
# arr也是从1开始计数
# 至少需要4n个结点：层高(lgn+1)，叶子结点个数2^(lgn+1)，总结点个数2*2^(lgn+1)=4n
class Node():
    def __init__(self):
        # 左右区间和区间统计
        self.l = None
        self.r = None
        self.sum = None
        # 是否延迟更新
        self.lz = 0
    
    def __add__(self, other):
        res = Node()
        res.l
        

class SegmentTree():
    def __init__(self, arr):
        n = len(arr)
        arr = [0]+arr
        self.arr = arr
        n = len(arr)
        self.tree = [Node() for _ in range(4*len(self.arr))]
        self.build(1,1,n)
        
    def push_up(self, i):
        # 节点更新
        self.tree[i].sum = self.tree[2*i].sum+self.tree[2*i+1].sum
    

    def build(self, i, l, r):
        # 建树
        # 节点i对应的区间l，r
        self.tree[i].l = l
        self.tree[i].r = r
        if l==r:
            self.tree[i].sum=self.arr[l]
            return
        mid = (l+r)//2
        self.build(2*i, l, mid)
        self.build(2*i+1, mid+1, r)
        self.push_up(i)

    # 1. 单点修改，区间查询，不需要push_down
    def add(self, i, dis, k):
        # 单点修改， self.arr[dis]+=k
        # 调用self.add(1, dis, k)
        if self.tree[i].l==self.tree[i].r:
            self.tree[i].sum+=k
            return
        if dis<=self.tree[2*i].r:
            self.add(2*i, dis, k)
        else:
            self.add(2*i+1, dis, k)
        self.push_up(i)
    
    def search(self, i, l, r):
        # 区间查询(单点修改)
        # 调用 self.search(1, l, r)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            return self.tree[i].sum
        if self.tree[i].r<l or r<self.tree[i].l:
            return 0
        s = 0
        if l<=self.tree[2*i].r:
            s = s+self.search(2*i, l, r)
        if self.tree[2*i+1].l<=r:
            s = s+self.search(2*i+1, l, r)
        return s

    
    # 2. 区间修改，单点查询：区间内所有数字进行更新，更新后某个点的更新情况
    # https://www.luogu.com.cn/problem/P3368
    # 和线段树的关系并不是很大
    # self.tree[i].sum 初始化为0，记录区间内数字的更新情况
    def build2(self, i, l, r):
        # 建树
        # 节点i对应的区间l，r
        self.tree[i].l = l
        self.tree[i].r = r
        if l==r:
            self.tree[i].sum=0
            return
        mid = (l+r)//2
        self.build(2*i, l, mid)
        self.build(2*i+1, mid+1, r)
        self.push_up(i)
    def search2(self, i, dis):
        # 单点查询
        # 从根节点一路加到叶子节点，就可以得到该位置数字的更新情况，再加上原始值，就可以得到更新后的数字
        self.ans+=self.tree[i].sum
        if self.tree[i].l==self.tree[i].r:
            self.ans += arr[l]
            return;
        if dis<=self.tree[i*2].r:
            self.search2(i*2, dis)
        if dis>=self.tree[i*2+1].l:
            self.search2(i*2+1, dis)
    
    def add2(self, i, l, r, k):
        # 区间修改 self.arr[l]+=k, arr[l+1]+=k, ..., arr[r]+=k
        if l<=self.tree[i].l and self.tree[i].r<=r:
            self.tree[i].sum+=k
            return
        if l<=self.tree[i*2].r:
            self.add2(i*2, l, r, k)
        if self.tree[i*2+1].l<=r:
            self.add2(i*2+1, l, r, k)
        self.push_up(i)

    # 3. 对于区间修改，区间查询，需要push_down
    # 初始化和 单点修改，区间查询一致 build
    # 区间修改，单点查询是区间修改，区间查询的特殊情况，两者代码可以合并
    def add3(self, i, l, r, k):
        # 第i个节点，区间修改, self.arr[l, r]+=k
        # 调用 self.add3(1, l, r, k)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            self.tree[i].sum+=k*(self.tree[i].r-self.tree[i].l+1)
            self.tree[i].lz+=k # 表示本区间的Sum正确，子区间的Sum仍需要根据lz的值来调整  
            return
        self.push_down(i)
        # 此时i的区间和lr肯定有交集，可以假设子区间的l或者r无穷
        if self.tree[2*i].r>=l:
            self.add3(2*i, l, r, k)
        if self.tree[2*i+1].l<=r:
            self.add3(2*i+1, l, r, k)
        self.push_up(i)
        return
    
    def push_down(self, i):
        # 下推标记
        # 如果没有下推标记或者叶子结点，结束下推
        if self.tree[i].lz==0 or self.tree[i].l==self.tree[i].r:
            return
        self.tree[2*i].lz+=self.tree[i].lz
        self.tree[2*i].sum+=(self.tree[2*i].r-self.tree[2*i].l+1)*self.tree[i].lz

        self.tree[2*i+1].lz+=self.tree[i].lz
        self.tree[2*i+1].sum+=(self.tree[2*i+1].r-self.tree[2*i+1].l+1)*self.tree[i].lz

        self.tree[i].lz=0
    
    def search3(self, i, l, r):
        # 区间查询
        # 调用 self.search3(1, l, r)
        if l<=self.tree[i].l and self.tree[i].r<=r:
            return self.tree[i].sum
        self.push_down(i) #  需要下推标记
        res = 0
        if l<=self.tree[2*i].r:
            res+=self.search3(2*i, l, r)
        if self.tree[2*i+1].l<=r:
            res+=self.search3(2*i+1, l, r)
        return res
```

## 307. 区域和检索 - 数组可修改

单点修改，区间查询

方法：线段树

```python
class Node():
    def __init__(self):
        self.l = 0
        self.r = 0 
        self.val = None

class NumArray:

    def __init__(self, nums: List[int]):
        if not nums:
            return 
        self.nums = nums
        n = len(nums)
        self.Tree = [Node() for _ in range(4*n)]
        self.build(1, 0, n-1)
    
    def push_up(self, i):
        self.Tree[i].val = self.Tree[i*2].val + self.Tree[i*2+1].val

    def build(self, i, l, r):
        print(i, len(self.Tree))
        self.Tree[i].l, self.Tree[i].r = l, r 
        if l==r:
            self.Tree[i].val = self.nums[l]
            return 
        mid = (l+r)//2
        self.build(i*2, l, mid)
        self.build(i*2+1, mid+1, r)
        self.push_up(i)

    def update(self, i: int, val: int) -> None:
        self.update2(1, i, val)
        return 

    def update2(self, index, i , val):
        if self.Tree[index].l==self.Tree[index].r:
            self.Tree[index].val=val
            return 
        if self.Tree[2*index].r>=i:
            self.update2(index*2, i, val)
        if self.Tree[2*index+1].l<=i:
            self.update2(index*2+1, i, val)
        self.push_up(index)

    def sumRange(self, i: int, j: int) -> int:
        return self.sumRange2(1, i, j)
    def sumRange2(self, index, i, j):
        if i<=self.Tree[index].l and self.Tree[index].r<=j:
            return self.Tree[index].val
        res = 0
        if self.Tree[2*index].r>=i:
            res+=self.sumRange2(index*2, i, j)
        if self.Tree[2*index+1].l<=j:
            res+=self.sumRange2(index*2+1, i, j)
        return res
```

## 308 二维区域和检索 - 可变

二维矩阵：单点修改，区间查询

方法：树状数组

```python
class NumMatrix():
    def __init__(self, matrix):
        self.m, self.n = len(matrix), len(matrix[0])
        self.C = [[0 for _ in range(n)] for _ in range(m)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                self.update(i, j, matrix[i-1][j-1])
    
    def update(self, i, j, val):
        j_tmp = j
        while i<self.m:
            j = j_tmp
            while j<self.n:
                self.C[i][j]+=val
                j += j&(-j)
            i+=i&(-i)
        return

    def sumRegion(self, i1, j1, i2, j2):
        return self.getsum(i2, j2)-self.getsum(i1, j2)-self.getsum(i2, j1)+self.getsum(i1, j1)
    
    def getsum(self, i, j):
        res = 0
        j_tmp = j
        while i>0:
            j = j_tmp
            while j>0:
                res+=self.C[i][j]
                j-=j&(-j)
            i-=i&(-i)
        return res
```

## 买卖股票收益最大问题

https://www.jianshu.com/p/9fa0faff99da

T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i])
T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i])

初始化：T[-1][k][0]=0, T[-1][k][1]=-sys.maxsize

```python
# 任意k 
import sys
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if not prices:
            return 0
        if k>=n/2:
            Tik0, Tik1 = 0, -sys.maxsize
            for i in range(n):
                Tik0_old = Tik0
                Tik0 = max(Tik0, Tik1+prices[i])
                Tik1 = max(Tik1, Tik0_old-prices[i])
            return Tik0
        Ti0 = [0 for _ in range(k+1)]
        Ti1 = [-sys.maxsize  for _ in range(k+1)]
        for i in range(n):
            for j in range(k, 0, -1):
                Ti0[j] = max(Ti0[j], Ti1[j]+prices[i])
                Ti1[j] = max(Ti1[j], Ti0[j-1]-prices[i])
        return Ti0[-1]
```

```python
# 有一天的冷静期
import sys
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        T_k0, T_k1 = 0, -sys.maxsize
        T_k0_old = 0
        for val in prices:
            T_k0_old_old = T_k0_old
            T_k0_old=T_k0
            T_k0 = max(T_k0, T_k1+val)
            T_k1 = max(T_k1, T_k0_old_old-val)
        return T_k0
```

## 310 最小高度树

定理1：最小高度树等价于图的直径的一半，其中图的直径定义为最远的两个节点之间的距离
证明：不妨假设图的直径两个节点是a,b，中间节点是c(如果有两个节点，就是c1, c2，不影响后续分析)，直径长度是d，那么我们可以令c为根，得到a，b的高度是d/2，且a，b的高度是此时高度树的高度，因为其他节点到c的距离不可能大于d/2，否则a, b就不是图的直径了。反证：如果最小高度树的根不在图的直径路径上，那么根到c的距离至少为1，根到a,b的的最大距离max(dis(根-a), dis(根-b))至少为2/d+1

定理2：BFS得到的高度树是最小高度树
证明：BFS每次删掉图中的所有叶子结点，直到剩下的节点都是叶子节点，此时剩下的叶子节点都可以为根节点。先考虑一个简单的过程：对于最小高度树，不妨假设高度是h，第一次只删除高度h的所有叶子节点，此时高度h-1的所有节点都是叶子节点，第二次只删除高度h-1的所有叶子节点，此时高度h-2的所有节点都是叶子节点，第三次只删除高度h-2的所有叶子节点，以此类推，第h次只删除高度1的所有叶子节点，剩下高度为0的根节点。再考虑比较复杂的过程(BFS)：对于第i次，不仅删除高度h-i的所有叶子节点，也删除高度小于h-i的叶子节点，我们需要证明这种删除方法不会提前删除根节点(等价于删除h次后根节点还是会被剩下)。根据定理1，不妨假设图的直径路径上只有一个中间节点c，a1-a2-a3-...-c-...-b3-b2-b1，此时a，b到c的距离相同，也意味着同时从a，b开始删除，第i(i< h)次删除ai, bi后，还剩ai+1-...-c-...-bi+1，根节点不会提前成为叶子节点。对于两个中间节点c1, c2: a1-a2-c1-c2-b2-b1，删除a1,b1,a2,b2后，剩下c1, c2，同时成为叶子节点，c1，c2也不会提前成为叶子节点被删除。

定理3：当图直径是偶数(直径的节点数为奇数时)，最小高度树的根节点是一个；当图直径是奇数(直径的节点数为偶数时)，最小高度树的根节点是两个
证明：由定理1的证明显然可以得到。

```python
from collections import deque
class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if not edges:
            return [0]
        q = deque()
        degree = [0 for _ in range(n)]
        e = [[] for _ in range(n)]

        for n1, n2 in edges:
            e[n1].append(n2)
            e[n2].append(n1)
            degree[n1]+=1
            degree[n2]+=1
        for i, val in enumerate(degree):
            if val==1:
                q.append(i)
                
        q2 = list()
        while q:
            q2 = list(q)
            q_size = len(q)
            for _ in range(q_size):
                node = q.popleft()
                for next_node in e[node]:
                    degree[next_node]-=1
                    if degree[next_node]==1:
                        q.append(next_node)
        return q2
        
```

## 311 稀疏矩阵的乘法

base: 以A为核心

```python
def multiply(A, B):
    for i:
        for k:
            for j:
                C[i][j] += A[i][k]*B[k][j]
```

以A为核心，进行优化

```python
class Solution {
public:
    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {
        vector<vector<int>> res(A.size(), vector<int>(B[0].size()));
        for (int i = 0; i < A.size(); ++i) {
            for (int k = 0; k < A[0].size(); ++k) {
                if (A[i][k] != 0) {
                    for (int j = 0; j < B[0].size(); ++j) {
                        if (B[k][j] != 0) res[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
        }
        return res;
    }
};
```

以A，B为核心，考虑稀疏性(推荐)
Time O(n^2 * (1 + a * b * n)) = O(n^2 + a * b * n^3)
Space O(b * n^2)

对于A[i][k]，查看B[k]中有哪些有数字

```python
def multiply(A, B):
    B_pos = [[] for _ in range(len(B))]
    res = [[0 for _ in range(len(B[0]))] for _ in range(len(A))]
    for k in range(len(B)):
        for j in range(len(B[0])):
            if B[k][j]:
                B_pos[k].append(j)  
    for i in range(len(A)):
        for k in range(len(A[0])):
            if A[i]==0:
                continue
            for j in B_pos[k]:
                res[i][j]+=A[i][k]*B[k][j]
    return res
```

## 312. 戳气球

定义 dp[l][r]: 表示开区间(l,r)之间的最大值，假设最后一个戳的气球位置是i\in [l+1, r-1]，则dp[l][r]=dp[l][i]+nums[l]* nums[i]* nums[r]+dp[i][r]，初始化dp[l][l+1]=0

从最后一行到第一行，从左到右开始遍历计算，要比斜着更新好写多了

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1]+nums+[1]
        n = len(nums)
        dp = [[0 for _ in range(n)] for _ in range(n)]
        for l in range(n-1, -1, -1):
            for r in range(l+2, n):
                for k in range(l+1, r):
                    dp[l][r] = max(dp[l][r], dp[l][k]+nums[l]*nums[k]*nums[r]+dp[k][r])
        return dp[0][-1]
```

## 313. 超级丑数

```python
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        primes_pos = [0 for _ in range(len(primes))]
        res = [1]
        for i in range(n-1):
            # print(res)
            tmp = min(res[pos]*primes[index] for index, pos in enumerate(primes_pos))
            res.append(tmp)
            for index, pos in enumerate(primes_pos):
                if tmp ==  res[pos]*primes[index]:
                    primes_pos[index]+=1
        return res[-1]
```

## 314 二叉树的垂直遍历

利用map得到每一列的节点：f(root, col) = map[col].append(root)+f(root.left, col-1)+f(root.right, col+1)

可以用bfs实现

```python
from collections import deque, d 
def verticalOrder(root):
    q = deque([(root, 0)])
    map = dict()
    while q:
        node, col = q.popleft()
        map[col]
```

## 315 计算右侧小于当前元素的个数  

方法一：合并排序

```python
class Solution:
    def countSmaller(self, nums: List[int]) -> List[int]:
        if not nums:
            return []
        n = len(nums)
        self.nums = [[val, i, 0] for i, val in enumerate(nums)]
        self.mergeSort(0, n-1)
        res = [0 for _ in range(n)]
        for val, i, cnt in self.nums:
            res[i]=cnt
        return res
    
    def mergeSort(self, l, r):
        if l==r:
            return
        mid = (l+r)//2
        self.mergeSort(l, mid)
        self.mergeSort(mid+1, r)
        self.merge(l, mid, r)
    
    def merge(self, l, mid, r):
        p1, p2 = l, mid+1
        tmp = [0 for _ in range(r-l+1)]
        p3 = 0
        while p1<=mid or p2<=r:
            if (not p1<=mid) or (p2<=r and self.nums[p1][0]>self.nums[p2][0]):
                tmp[p3]=self.nums[p2]
                p2+=1
            else:
                tmp[p3]=self.nums[p1]
                tmp[p3][2]+=p2-mid-1
                p1+=1
            p3+=1
        self.nums[l:r+1] = tmp
```

方法二：离散化+树状数组

对于数组 [5,5,6,3]:可以得到hashset [0,1,2,3,4,5,6]:[0,0,1,0,2,1]，对于第一个5而言，就是求hashset的前缀和，可以利用树状数组求。

方法三：二叉搜索树

二叉搜索树可以快速计算出小于val的节点个数：root节点cnt保存左子树节点的个数，从右向左遍历
f(root, val): 
如果val>root:说明新增节点位于根节点的右子树，并且此时小于该val的节点个数(原数组右侧小于val的个数)=根节点的cnt+1+f(root.right, val)
如果val< root，说明新增节点位于根节点的左子树，根节点的cnt+=1

```python
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        //初始化
        Integer[] res = new Integer[nums.length];
        Arrays.fill(res, 0);
        List<Integer> list = new ArrayList<>();
        //反向构造二叉树，统计右边的较小数
        TreeNode root = null;
        for (int i = nums.length - 1; i >= 0; i--){
            root = addAndCount(root, new TreeNode(nums[i]), res, i);
        }
        return Arrays.asList(res);
    }

    public TreeNode addAndCount(TreeNode root, TreeNode node, Integer[] res, int i){
        if(root == null){
            root = node;
            return root;
        }
        //根节点的左边保存不大于根节点的元素
        if(root.val >= node.val){ 
            //统计左节点的元素个数
            root.count++;
            root.left = addAndCount(root.left, node, res, i);
        }else{
            //走到右边获取该元素左边的个数（根节点 1 + 左节点 root.count）
            res[i] += 1 + root.count;
            //统计右边是否还有更小的元素
            root.right = addAndCount(root.right, node, res, i);
        }
        return root;
    }
}

class TreeNode{
    int val;
    int count;
    TreeNode left, right;

    public TreeNode(int val){
        this.val = val;
        this.count = 0;
        left = null;
        right = null;
    }
}
```

## 316. 去除重复字母

去除重复字母，并且得到的结果字典序最小

方法一：贪心

贪心：字典序最小，即第一个字符尽可能小，然后保证第二个字符尽可能小，依次类推。最左侧的字符是在能保证其他字符至少能出现一次情况下的最小字符。对于第一个字符s[pos]，pos之右其他所有字符至少出现过一次。pos可以取值的范围[0, ... j]:j=min(j1, j2..)，其中j1是s[j1]的最后一次出现位置，j2同理，所以，j是s[j]的最后一次出现位置，并且开区间(j,...n)中其他所有字符至少出现过一次。并且s[pos]=min(s[0]...s[j])
证明：假设这种贪心方法取得的字符串"b..."(对应的原字符串位置是i1)不是字典序最小，最小的字符串是"a.."(对应原字符串位置是 k1)，对于贪心字符串的第一个字符b(i1)，以及贪心的规则，可以得出[0, j]之间没有出现a(k1>j)，并且j是s[j](!=a)最后一次出现的位置。最优字符串第一个字符是a(k1>j)，且最优字符串中s[j]的位置大于k1，与贪心规则相矛盾。

```python
from collections import Counter
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        if not s:
            return ""
        s_map = {val:i for i, val in enumerate(s)}
        cnt = min(s_map.values())
        pos = 0
        for i in range(cnt+1):
            if s[pos]>s[i]:
                pos = i
        return s[pos]+self.removeDuplicateLetters(s[pos:].replace(s[pos], ""))
```
    pre_pos = -1
    s_map = {val: i for i, val in enumerate(s)}
    while s_map:
        s_map = {val: i for i, val in enumerate(s) if val not in seen}
        cnt = min(s_map.values())
        pos = pre_pos+1
        for i in range(pre_pos+1, cnt+1):
            if s[pos]>s[i]:
                pos = i
        seen.add(pos)
        pre_pos = pos

方法二：贪心+单调栈

单调栈：区间单调栈，比如 1 3 4 7, 5 8, 6 9 其中1 3 4 7单调，5 8 单调，6 9 单调，且7 8 9都是最后一次出现

定义贪心+单调栈stack的入栈规则：

1. 如果arr[cur]在stack中出现，跳过
2. 如果arr[cur]没有在stack中出现，且小于stack[-1]且stack[-1]在之后在cur之后还会再次出现，则弹出栈顶
3. 如果arr[cur]没有在stack中出现，但是不满足条件2，压入

不难得出，这种单调栈入栈规则得到的栈中，或者满足arr[stack[k-1]]< arr[stack[k]]，或者last_occur[arr[stack[k-1]]]< stack[k]

回顾方法一 贪心的计算过程，可以简化为：
第一步：计算jj0=min(j0, j1,..j25)，求出pos0=min(arr[0]...arr[jj0])
第二步：计算jj1=min(j0, j1...j24), 求出pos1=min(arr[pos0+1]...arr[jj1])
第三步：计算jj2=min(j0, j1...j23), 求出pos2=min(arr[pos1+1]...arr[jj2])
...
仔细分析上述过程，对于每一步求出的posk，都有两种情况:arr[posk]=arr[jjk]或者arr[posk]!=arr[jjk]，对于前者有jj{k+1}!=jjk，对于后者jj{k+1}=jjk，即栈只有取到jjk(如果取到的位置是jjk'< jjk，但是arr[jjk']=arr[jjk]，我们可以视为取到的是jjk位置的元素，因为jjk'到jjk之间的其他字符在jjk之后一定还会出现，下一个字符=min(jjk'+1, jj{k+1})=min(jjk+1, jj{k+1})时，下一个jj才能不同。或者说，对于jj0，需要一直从小到大取单调栈到jj0，再求jj1，再从小到大取单调栈到jj1，再求jj2...。不妨假设jj0==jj1, jj2==jj3，因此有
pos0=min(arr[0]...arr[jj0])，
pos1=min(arr[pos0+1]...arr[jj0])，且arr[pos1]==arr[jj0]，
pos2=min(arr[pos1+1]...arr[jj2])，
pos3=min(arr[pos1+1]...arr[jj2])，且arr[pos2]==arr[jj2]
符合单调栈的模型四的改进模型。
last_occur就是seggg

如果arr[i]< arr[stack[-1]] 且i<=last_occur[ arr[ stack[-1]]]，弹出(while)(其中last[len(stack)-1]表示stack[-1]对应的jk)
压入arr[i]

需要注意的是，方法一 贪心法的计算过程每得到一个字符，就会在之后的字符串中删除该字符，因此我们在入栈的时候，在已经有stack[0]的情况下，遇到相同的值需要跳过。

```python
from collections import Counter
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = list()
        seen = set()
        last_occur = {val:i for i, val in enumerate(s)}
        for i in range(len(s)):
            if s[i] in seen:
                continue
            while stack and s[i]<stack[-1] and i<last_occur[stack[-1]]:
                tmp = stack.pop()
                seen.discard(tmp)
            stack.append(s[i])
            seen.add(s[i])
        return ''.join(stack)
```

方法三：单调栈+弹出限制

每个字母移除remain_counter[c]-1次

```python
class Solution:
    def removeDuplicateLetters(self, s) -> int:
        stack = []
        seen = set()
        remain_counter = collections.Counter(s)

        for c in s:
            if c not in seen:
                while stack and c < stack[-1] and  remain_counter[stack[-1]] > 0:
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1
        return ''.join(stack)
```

## 单调栈

### 一、简单的单调栈：

给定字符串arr，从前到后遍历，建立单调栈(从小到大)(stack中记录的是原数组的位置)，得到的最后单调栈stack。等价于

单调栈入栈规则：
如果arr[i]< arr[stack[-1]]，弹出stack[-1] (while)
如果arr[i]> arr[stack[-1]], 压入

对于建立过程中i的stack，有：
arr[stack[0]]=min(arr[0]         , ... arr[i])
arr[stack[1]]=min(arr[stack[0]+1], ... arr[i])
arr[stack[2]]=min(arr[stack[1]+1], ... arr[i])

对于最终结果stack有：
arr[stack[0]] =min(arr[0]         , ... arr[n-1])
arr[stack[1]]=min(arr[stack[0]+1], ... arr[n-1])
arr[stack[2]]=min(arr[stack[1]+1], ... arr[n-1])
...
也就是stack[i]都是stack[i-1]+1到n-1的数组arr最小值，且stack[i]的数组arr从小到大

图形

```python
# \       /\     /\
#  \     /  \   /  \
#   \   /    \ /    5
#    \ /      4
#     3
for i in range(n):
    while stack and arr[i]<arr[stack[-1]]:
        stack.pop()
    stack.append(i)
```

### 二、滑动窗口(窗口固定大小)的最小值

单调栈stack满足:
arr[stack[0]] = min(arr[0], ..., arr[w-1])
arr[stack[1]] = min(arr[1], ..., arr[w])
arr[stack[2]] = min(arr[2], ..., arr[w+1]])

单调栈：从小到大
限制条件：栈底元素与当前位置i的距离小于窗口w

证明：假设已经得到区间[i-w+1, i]的单调栈stack1，如何得到区间[i-w+2, i+1]的单调栈stack2？
stack1的栈底元素有两种可能：
第一种：栈底stack1[0]就是i-w+1，表示[i-w+1, i]的最值，同时[stack1]表示[stack1[0]+1, i]=[i-w+2, i]的最值，显然，需要删除stack1的栈底，删除的栈底元素表示[i-w+2, i]的最值, 按照单调栈入栈规则压入i+1，得到的新栈的栈底表示[i-w+2, i+1]的最值。
第二种：栈底stack1[0]不是i-w+1，那么栈底stack1[0]可以表示[i-w+2, i]的最值，按照单调栈入栈规则压入i+1，得到的新栈的栈底表示[i-w+2, i+1]的最值。
根据第一种和第二种情况，可以得出对于当前i，需要保证栈底元素在窗口[i-w+1, i]中

### 模型三、我也不知有啥应用场景

单调栈stack满足:
arr[stack[0]] = min(arr[0]         , .., arr[j0])
arr[stack[1]] = min(arr[stack[0]+1], .., arr[j1]])
arr[stack[2]] = min(arr[stack[1]+1], .., arr[j2]])
...
其中last=[j0, j1, j2 ...]，满足j0<=j1<=j2...,且jm=n-1


定义修改后的单调栈入栈规则：
如果arr[i]< arr[stack[-1]] 且i<=last[len(stack)-1]，弹出(while)(其中last[len(stack)-1]表示stack[-1]对应的jk)
如果arr[i]>arr[stack[-1]]，压入
最后取stack[:len(last)]

```python
last = [j0, j1, j2]
stack = list()
for i, val in range(arr):
    while stack and i<=last[len(stack)-1] and va<stack[-1]:
        stack.pop()
    stack.append(val)
res = stack[:len(last)]

```

证明上述的单调栈入栈规则正确。数学归纳法
对于stack[0]：当i遍历到j0，上述单调栈入栈规则可以得到arr[stack[0]] = min(arr[0]        , .., arr[j0])
假设当i遍历到j{k-1}时，上述单调栈入栈规则可以得到stack[0],..., stack[k-1]。备注：单调栈stack中此时的元素个数可能大于k个，但是只要前k个元素是stack[0],..., stack[k-1]，且后续不会发生改变即可。
当i遍历到j{k}时，需要证明可以得到stack[0],..., stack[k-1], stack[k]。我们令i从0遍历到stack[k-1]，可以得到stack[0],..., stack[k-1]。分为两种情况：
第一种：stack[k]在[stack[k-1]+1, j{k-1}]中，有stack[k]>stack[k-1]，那么当i从stack[k-1]+1遍历到j{k-1}时，得到stack[k]，stack[k-1]不会弹出，当i从j{k-1}遍历到jk时，因为stack[k]=min(arr[stack[k-1]+1],..., arr[j{k-1}])，所以stack[k]不会被弹出，此时我们可以得到stack[0],..., stack[k]，备注，此时stack[k]之后可能有一些其他值
第二种：stack[k]在[j{k-1}+1, jk]中。当i从stack[k-1]遍历到j{k-1}时，stack[k-1]不会被弹出。当i从j{k-1}+1遍历到stack[k]时，如果栈顶有除stack[k-1]之外的元素，那么stack[k]会把这些元素弹出(因为此时len(stack)>=jk>=i)，直到stack[k-1]，然后压入stack[k]，当i从stack[k]+1遍历到jk时，因为stack[k]是[ stack[k], jk]中的最小值，所以stack[k]不会被弹出。得证。

从另一个角度分析：
arr[stack[0]] = min(arr[0]         , .., arr[j0])
当i从0遍历到stack[0]时，即使栈顶有其他元素，也会被弹出，然后压入stack[0]
从stack[0]遍历到j0时，stack[0]不会被弹出，同时栈顶也可能会有其他元素
当i遍历到j0以后时，因为i<=last[len(stack)-1]，stack[0]也不会被弹出
arr[stack[1]] = min(arr[stack[0]+1], .., arr[j1]])
当i从stack[0]+1遍历到stack[1]时，会压入stack[1]
当i从stack[1]遍历到j1时，stack[1]因为是最小不会被弹出
当i从j1遍历到以后时，stack[1]因为i<=last[len(stack)-1]，也不会被弹出
或者分为两种情况：stack[1]在stack[0]+1到j0之间，或者stack[1]在j0到j1之间
stack[1]在stack[0]+1到j0之间：i从stack[0]遍历到stack[1]，会得到stack[1]，i从stack[1]遍历到j1时，因为min不会被弹出，i从j1开始遍历时，因为不满足i<=last[len(stack)-1]，不会被弹出。
stack[1]在j0到j1之间：i遍历stack[0]到j0时，会得到stack[1]的候选，从j0到j1时，碰到stack[1]，则会弹出stack[1]的候选，压入真值stack[1]，并且之后不会被弹出，当i从j1开始遍历时，因为不满足i<=last[len(stack)-1]，不会被弹出
此时stack[1]可能小于stack[0]


### 模型四、去除重复字母：贪心+单调栈

单调栈stack满足:
arr[stack[0]] = min(arr[0]         , .., arr[j0])
arr[stack[1]] = min(arr[stack[0]+1], .., arr[j0]]) (暗含stack[1]==j0)
...
arr[stack[2]] = min(arr[j0], .., arr[j1]])
arr[stack[3]] = min(arr[stack[2]+1], .., arr[j1]])
...
其中j0<=j1<=j2，即给定j0，先求出[0, j0]的单调栈，再求出[j0+1, j1]的单调栈，...

定义修改后的单调栈入栈规则：
segg = [j0, j0...j1, j1]，len(segg)==len(arr)，即把小于等于jk大于j{k-1}的位置都赋值jk
如果arr[i]< arr[stack[-1]] 且i<=segg[stack[-1]]，弹出(while)(其中last[len(stack)-1]表示stack[-1]对应的jk)
压入arr[i]

证明：当i从0遍历到j0，求出[0, j0]的单调栈stack[0, 1]，当i从j0+1遍历到n-1时，因为i<=segg[stack[-1]]，所以stack[0, 1]不会被弹出
当i从j0遍历到j1，求出[j0+1, j1]的单调栈stack[2, 3]，当i从j1+1遍历到n-1时，因为因为i<=segg[stack[-1]]，所以stack[2, 3]不会被弹出

模型四的改进版

进一步，我们可以定义seggg=[ xx, xx,..., j0, x, x, j1]，举例 j0=2, j=5，n=6，seggg[3, 3, 2, 6, 5]，只要满足seggg[j0]=j0, seggg[j1]=j1，j{k-1}与j{k}之间的值大于等于jk即可

如果arr[i]< arr[stack[-1]] 且i<=seggg[stack[-1]]，弹出(while)(其中last[len(stack)-1]表示stack[-1]对应的jk)
压入arr[i]

证明：当i从0遍历到j0时，求出[0, j0]的单调栈stack[0, 1]，并且显然arr[j0]一定会在栈顶(否则我们总是可以在stack[-1]+1到j0之间找到最小值)，当i从j0+1遍历到n-1时，因为stack[1]=arr[j0]，seggg[j0]=j0，所以i<=seggg[stack[-1]]使得stack[1]无法弹出
当i从j0+1遍历到j1时，可以求出[j0+1, j1]的单调栈stack[2, 3]，并且显然arr[j1]一定会在栈顶，当i从j1+1遍历到n-1时，i<=seggg[stack[-1]]使得stack[3]无法弹出

或者理解成当i和stack[-1]同时属于一个区间时(i<=last[stack[-1]])，才需要满足从小到大的单调栈，当i和stack[-1]不属于同一个区间时，不需要弹出

备注：模型三和四的主要区别在于给定j0，arr[j0]是否一定会被选到栈中，模型三没有强制要求，模型四暗含强制要求

### 模型五：单调栈+弹出限制

https://leetcode-cn.com/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/

两个相同位数的数字大小关系取决于第一个不同的数的大小，所以可以贪心地删除栈中相邻的字符

402 移掉 K 位数字

单调栈最多弹出K次

对于每一个字符，如果弹出次数小于k，我们可以选择丢弃或者保留，否则不可以丢弃

```python
def removeKdigits(self, num, k):
    stack = []
    remain = len(num) - k
    for digit in num:
        while k and stack and stack[-1] > digit:
            stack.pop()
            k -= 1
        stack.append(digit)
    return ''.join(stack[:remain]).lstrip('0') or '0'
```

316 去除重复字母

每个字母c移除remain_counter[c]-1次

建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。
从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1.
对于每一个字符，如果其对应的剩余出现次数大于 1，我们可以选择丢弃（也可以选择不丢弃），否则不可以丢弃。
如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。

```python
class Solution:
    def removeDuplicateLetters(self, s) -> int:
        stack = []
        seen = set()
        remain_counter = collections.Counter(s)

        for c in s:
            if c not in seen:
                while stack and c < stack[-1] and  remain_counter[stack[-1]] > 0:
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
            remain_counter[c] -= 1 # 入栈的时候提前算一次移除次数
        return ''.join(stack)
        # 或者
        for c in s:
            if c not in seen:
                while stack and c < stack[-1] and  remain_counter[stack[-1]] > 1:
                    remain_counter[stack[-1]]-=1 # 出栈的时候算一次移除次数
                    seen.discard(stack.pop())
                seen.add(c)
                stack.append(c)
            else:
                remain_counter[c] -= 1
```

```python
from collections import Counter
class Solution:
    def removeDuplicateLetters(self, s: str) -> str:
        stack = list()
        seen = set()
        last_occur = {val:i for i, val in enumerate(s)}
        for i in range(len(s)):
            if s[i] in seen:
                continue
            while stack and s[i]<stack[-1] and i<last_occur[stack[-1]]:
                tmp = stack.pop()
                seen.discard(tmp)
            stack.append(s[i])
            seen.add(s[i])
        return ''.join(stack)
```

## 402. 移掉 K 位数字（中等）

移除k个数字等价于保留n-k个数字

方法一：单调栈+弹出限制

最多移除K个数字==最多弹出K次
单调栈最后可能有超过n-k个数字，只需要保留n-k个数字即可

```python
class Solution(object):
    def removeKdigits(self, num, k):
        stack = []
        remain = len(num) - k
        for digit in num:
            while k and stack and stack[-1] > digit:
                stack.pop()
                k -= 1
            stack.append(digit)
        return ''.join(stack[:remain]).lstrip('0') or '0'
```

方法二：单调栈模型三

以 1432219,n=7, k=3为例，保留4=n-k个数字

第一个数字pos0=min(arr[0], arr[1], arr[2], arr[3])=min(arr[0],..., arr[k])
第二个数字pos1=min(arr[pos0+1],..., arr[4])=min(arr[pos0+1],..., arr[k+1])
第三个数字pos2=min(arr[pos1+1],..., arr[5])=min(arr[pos1+1],..., arr[k+2])
第四个数字pos3=min(arr[pos2+1],..., arr[6])=min(arr[pos2+1],..., arr[k+3])

第五个数字pos4=min(arr[pos3+1],..., arr[6])=min(arr[pos3+1],..., arr[n-1])
一直到posm=n-1

之所以第一个数字取到k，是为了给后续的数字取值的空间，否则如果第一个数字的最小值在第n-1位，第二个数字就没法取了

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        stack = []
        remain = len(num)-k
        for i, digit in enumerate(num):
            while stack and i<len(stack)+k and digit<stack[-1]:
                stack.pop()
            stack.append(digit)
        res = ''.join(stack[:remain]).lstrip('0')
        if not res:
            return "0"
        return res
```

## 317. 离建筑物最近的距离

BFS：从目的地开始BFS

需要记录当前建筑物BFS的是否访问和距离，并且计算第一个建筑物到当前建筑物对0的访问次数和距离

对于有分割的建筑物i和j，对i进行BFS之后，对j进行BFS时，会发现第j个建筑物周围的点的遍历次数不是j-1次。

为了方便比较建筑物周围点的遍历次数，BFS时，我们对建筑物也进行遍历，这样，我们只需要比较建筑物j被遍历的次数是否等于j-1次即可。

```python
from collections import deque
import sys
class Solution:
    def shortestDistance(self, grid):
        n, m = len(grid), len(grid[0])
        dist = [[0 for _ in range(m)] for _ in range(n)]
        cnt = [[0 for _ in range(m)] for _ in range(n)]
        buildcnt=0
        delta = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        print

        def in_area(x, y):
            return 0<=x<n and 0<=y<m

        def dfs(i, j):
            nonlocal buildcnt
            print(i, j, buildcnt, cnt[i][j])
            if buildcnt!=cnt[i][j]:
                return False
            buildcnt+=1
            q = deque([(i, j, 0)])
            while q:
                i, j, dis_cur = q.popleft()
                dist[i][j]+=dis_cur
                cnt[i][j]+=1
                for dx, dy in delta:
                    x, y = i+dx, j+dy
                    if in_area(x, y) and grid[x][y]!=2 and cnt[x][y]==buildcnt-1:
                        q.append((x, y, dis_cur+1))
            return True

        for i in range(n):
            for j in range(m):
                if grid[i][j]==1:
                    if not dfs(i, j):
                        return -1

        res = sys.maxsize
        for i in range(n):
            for j in range(m):
                if grid[i][j]==0 and cnt[i][j]==buildcnt:
                    res=min(res, dist[i][j])
        return res
```

## 318. 最大单词长度乘积

利用bitmask代替set，完成set的交集:x&y==0

```python
from collections import defaultdict
class Solution:
    def maxProduct(self, words: List[str]) -> int:
        n = len(words)
        hashmap = defaultdict(int)
        for i, word in enumerate(words):
            bitmask = 0
            for c in word:
                bitmask |= 1<<(ord(c)-ord("a"))
            hashmap[bitmask] = max(hashmap[bitmask], len(word))
        
        res = 0
        for x in hashmap:
            for y in hashmap:
                if x&y==0:
                    res = max(res, hashmap[x]*hashmap[y])
        return res

```

## 319 灯泡开关

假设灯泡从1开始编号到n，刚开始为关闭
第一轮: 全部打开
第二轮：第2，4，6，8....切换开关
第三轮：第3 6 9 12 ...切换开关
...

对于第i个灯泡，一共被切换了g(i)次。其中g(i)表示因子数量，如果g(i)为奇数，则最后为开，如果g(i)为偶数，则最后为关。

对于n，如果m为n的因子，则n/m也是n的因子。如果m!=n/m，则对于每一个m都有n/m作为另一个因子，即因子成对出现。如果存在m==n/m,则对于n而言，有奇数个因子。当m=n/m，有n=m^2，是完全平方数。

所以最后剩下亮着的灯泡个数等于完全平方数的个数(1,4,9...),即sqrt(n)个

```python
class Solution:
    def bulbSwitch(self, n: int) -> int:
        res = int(n**0.5)
        return res
```

## 320 列举单词的全部缩写

```python
def generateAbbreviations(word):
    res = list()
    path = list()
    n = len(word)
    def helper(pos):
        if n==pos:
            res.append(''.join(map(str, path)))
            return
        path.append(word[pos])
        helper(pos+1)
        path.pop()
        
        if path and isinstance(path[-1], int):
            path[-1]+=1
            helper(pos+1)
            path[-1]-=1
        else:
            path.append(1)
            helper(pos+1)
            path.pop()
    helper(0)
    return res
```

## 321 拼接最大数

对于k，分别在nums1和nums2中取到字典序最大，然后按照字典序最大进行拼接

字典序最大拼接：比如arr1=[6,8]和arr2=[6,7]，第一个6应该取arr1，因为arr1的字典序比arr2大，应该尽量先取到8，而不是7。

```python
class Solution:
    def maxNumber(self, nums1: List[int], nums2: List[int], k: int) -> List[int]:
        def helper(nums, k):
            n = len(nums)
            drop = n-k
            stack = list()
            for i, val in enumerate(nums):
                while stack and drop and val>stack[-1]:
                    drop-=1
                    stack.pop()
                stack.append(val)
            return stack[:k]
        
        def merge(arr1, arr2):
            res = list()
            pos1, pos2 = 0, 0
            while pos1<len(arr1) or pos2<len(arr2):
                if (not pos2<len(arr2)) or (pos1<len(arr1) and arr1[pos1:]>arr2[pos2:]):
                    res.append(arr1[pos1])
                    pos1+=1
                else:
                    res.append(arr2[pos2])
                    pos2+=1
            return res
        
        res = [0 for _ in range(k)]
        for k1 in range(min(len(nums1), k)+1):
            k2 = k-k1
            if k2>len(nums2):
                continue
            cur = merge(helper(nums1, k1), helper(nums2, k2))
            res = max(res, cur)
        return res
```

